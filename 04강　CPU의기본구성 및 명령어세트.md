## 🦄 CPU의 기본 구성 및 명령어 세트 (4 / 13회차)
<br>

### 2.1 CPU의 기본 구조　　　　	`secho`

0번

다음은 기억장치에 저장된 명령어들을 실행함으로써 프로그램을 수행시키는 CPU의 동작과정이다.

순서에 맞게 나열해주세요.

가. 데이터 인출

나. 데이터 저장

다. 명령어 인출

라 데이터 처리

마 명령어 해독



`__`와 `__`는 공통적으로 수행되지만 `___, ___, ___`는 필요한 경우에만 수행한다.



1번 

빈칸에 알맞은 답을 채워주시고 간단한 설명도 작성해주세요.

CPU는 `_____`,`_____`,`_____` 으로 구성된다.



2번

보기를 보고 알맞은 답을 채워주세요

`가장 느리고, 가장 빠르고,  범용 레지스터, 특수기능 레지스터, 제어유닛, STORE, JUMP, IR, AR, VR, XR, MR MAR, MDR, MRI, PC, UCC, KCC, AC, SP, HP`,

CPU내부의 다양한 레지스터들의 집합인 레지스터 세트는 액세스 속도가 기억장치들 중 `1) _____`,

 종류로는  크게 `2) ________`와 `3) ________`가 있다.

`2)____`에는 4)`__`,`__`,`__`,`__`,`___`,`___`으로 이루어져있다





3번

다음은 CPU 내부 구조에 대한 대화입니다.

대화내용을 읽고 틀리게 말한 사람을 고르세요

![](https://images.velog.io/images/secho/post/56f382f4-05ba-48d3-9d81-001bda2a7ba9/image.png)



Kukim : 왼쪽 네모그림 안에있는 구성요소들이 CPU의 내부 요소야 바로 ALU, 레지스터 셋, 제어유닛이 포함되어있지.

Daelee : 아 그렇구나 PC위에 있는 +는 뭐야?

Yeosong : 그건 내가 얘기해줄게, PC는 이전에 인출했던 명령어 주소값을 가진 레지스터인데 명령어가 인출된 이후에 자동적으로 주소값이 1씩 증가되어서 가장 최근에 수행된 명령어 주소값을 가리키게 돼

Jakang : 아하 그렇구나 어 보니까 CPU Internal Bus는  CPU 내부에서만 사용하고 외부랑 직접적으로 연결이 되어있지 않네? 왜 그렇지? 그러면 어떻게 외부랑 접속될 수 있어?

Taelee : 그건 CPU 내부 처리속도와 외부 처리속도랑 차이가 있기 때문이야. 그래서 직접 연결하지 않고 간접적으로 버퍼 레지스터인 MDR, MAR를 통해 시스템 버스와 접속해.

Jehong : 아항 어라 근데 또 보니까 Address Bus는 Data Bus와 다르게 단방향이네? 왜지?

Taelee : Address Bus가 단방향인 이유는 CPU로부터 메모리에게 주소값을 전송하지만, 반대로의 전송은 필요가 없기 때문이야



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

0번

다음은 기억장치에 저장된 명령어들을 실행함으로써 프로그램을 수행시키는 CPU의 동작과정이다.

순서에 맞게 나열해주세요.

가. 데이터 인출

나. 데이터 저장

다. 명령어 인출

라 데이터 처리

마 명령어 해독



`다`와 `마`는 공통적으로 수행되지만 `가, 나, 라`는 필요한 경우에만 수행한다.

명령어인출과 해독은 공통적이지만 데이터 인출, 처리, 저장단계는 데이터가 필요한 경우에만 수행되기 때문(명령어 실행을 위한 데이터가 필요없는 경우도 있기 때문에.)



1번

CPU는 `ALU`,`레지스터 셋`,`제어유닛` 으로 구성된다.

- ALU : CPU 내부에서 산술 및 논리 연산을 수행하는 하드웨어 모듈
- 레지스터 셋: CPU 내부의 다양한 레지스터들의 집합.
  - CPU내부에서 처리되기 때문에 액세스 속도가 컴퓨터 기억장치들 중에서 가장 빠름
  - CPU내의 한정된 영역에 넣어야 하기 때문에 제한적임
- 제어유닛 : 명령어의 연산코드(Op-code)를 해석하고 그것을 실행하기 위한 제어 신호들을 순차적으로 발생시키는 하드웨어 모듈
  - 명령어 실행에 필요한 각 정보들의 전송 통로 방향을 지정
  - CPU 내부 요소들과 시스템 구성 요소들의 동작시간도 결정해줌

2번

보기를 보고 알맞은 답을 채워주세요

`가장 느리고, 가장 빠르고,  범용 레지스터, 특수기능 레지스터, 제어유닛, STORE, JUMP, IR, AR, VR, XR, MR MAR, MDR, MRI, PC, UCC, KCC, AC, SP, HP`,

CPU내부의 다양한 레지스터들의 집합인 레지스터 세트는 액세스 속도가 기억장치들 중 `1) 가장 빠르고`,

 종류로는  크게 `2) 특수기능 레지스터`와 `3) 범용 레지스터`가 있다.

`2)특수기능 레지스터`에는 4) `PC`,`IR`,`AC`,`SP`,`MAR`,`MDR`으로 이루어져있다



3번

다음은 CPU 내부 구조에 대한 대화입니다.

대화내용을 읽고 틀리게 말한 사람을 고르세요

![](https://images.velog.io/images/secho/post/56f382f4-05ba-48d3-9d81-001bda2a7ba9/image.png)



Kukim : 왼쪽 네모그림 안에있는 구성요소들이 CPU의 내부 요소야 바로 ALU, 레지스터 셋, 제어유닛이 포함되어있지.

Daelee : 아 그렇구나 PC위에 있는 +는 뭐야?

Yeosong : 그건 내가 얘기해줄게, PC는 이전에 인출했던 명령어 주소값을 가진 레지스터인데 명령어가 인출된 이후에 자동적으로 주소값이 1씩 증가되어서 가장 최근에 수행된 명령어 주소값을 가리키게 돼

Jakang : 아하 그렇구나 어 보니까 CPU Internal Bus는  CPU 내부에서만 사용하고 외부랑 직접적으로 연결이 되어있지 않네? 왜 그렇지? 그러면 어떻게 외부랑 접속될 수 있어?

Taelee : 그건 CPU 내부 처리속도와 외부 처리속도랑 차이가 있기 때문이야. 그래서 직접 연결하지 않고 간접적으로 버퍼 레지스터인 MDR, MAR를 통해 시스템 버스와 접속해.

Jehong : 아항 어라 근데 또 보니까 Address Bus는 Data Bus와 다르게 단방향이네? 왜지?

Taelee : Address Bus가 단방향인 이유는 CPU로부터 메모리에게 주소값을 전송하지만, 반대로의 전송은 필요가 없기 때문이야



Yeosong: 이전이 아니라 다음에 인출할 명령어 주소값을 가진 레지스터임, 명령어 인출 후에는 1씩증가되는게 아니라 컴퓨터가 한번에 처리할 수 있는 크기, 즉 워드 크기만큼 증가한다.



</details>
<br><br>

### 2.4 명령어 세트 - 연산의 종류, 명령어형식　　　　　	`yeha`

1. 보기에 있는 연산과 연산에 대한 설명을 알맞게 짝지어 보세요. 

```c
(가) 산술 연산 (나) 프로그램 제어 (다) 데이터 전송 (라) 논리 연산 (마) 입출력 (I/O) 
```

- 레지스터와 레지스터 간, 레지스터와 기억장치 간, 기억장치와 기억장치 간에 데이터를 이동시키는 동작 `_________`
- 덧셈, 뺄셈, 곱셈, 나눗셈과 같은 기본적인 산술 연산 `_________`
- 데이터의 각 비트들 간에 대한 AND, OR, NOT, Exclusive-OR 등과 같은 연산 수행 `_________`
- CPU와 외부 장치들 간에 데이터 이동을 위한 동작 `_________`
- 각 명령어의 실행 순서를 변경하는 연산 `_________`

2. 다음 용어에 대해 간단히 설명해 보세요.

- 연산 코드 (오퍼레이션 코드, Operation Code, Op-code)
- 오퍼랜드 (Operand)

3. 다음 설명에 대해 맞으면 O, 틀리면 X 하세요. 

- 명령어는 CPU가 한 번에 처리할 수 있는 비트의 수로 처리된다. (O/X)

- 명령어를 구성하는 비트는 용도에 따라 몇 개의 필드 (Field) 로 나눠진다. 이 때 연산 코드 (Op-code)와 오퍼랜드 (Operand) 필드는 하나씩만 사용된다. (O/X)

- 명령어 형식 (instruction format) 은 명령어를 구성하는 필드의 종류&개수&배치 방식, 필드 당 비트 수를 정의한 형식이다. (O/X)

- 3-주소 명령어를 사용하면 프로그램이 짧아진다. (O/X)

4. 16비트 CPU는 한 번에 16비트 단위의 데이터 처리가 가능하고, CPU의 명령어 길이도 16비트입니다. 
주어진 명령어 형식을 따른다고 할 때, 빈칸을 알맞게 채워보세요.  

- 1-주소 명령어 (1-address instruction)에서 연산 코드는 4비트, 오퍼랜드는 12비트다.   
연산 종류는 `___`가지다.


- 2-주소 명령어에서 연산 코드는 4비트, 오퍼랜드1은 4비트, 오퍼랜드2는 8비트다. 오퍼랜드1만 레지스터다.  
연산의 종류는 (1) `___`가지,   
레지스터의 개수는 (2) `___`개,  
기억장치 주소 영역의 범위는 (3) `___` ~ `___-1`,  
데이터의 표현 범위는 (4) `___` ~ `___-1` 다.


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
1. 보기에 있는 연산과 연산에 대한 설명을 알맞게 짝지어 보세요. 

```c
(가) 산술 연산 (나) 프로그램 제어 (다) 데이터 전송 (라) 논리 연산 (마) 입출력 (I/O) 
```

- 레지스터와 레지스터 간, 레지스터와 기억장치 간, 기억장치와 기억장치 간에 데이터를 이동시키는 동작 ((다) 데이터 전송)
- 덧셈, 뺄셈, 곱셈, 나눗셈과 같은 기본적인 산술 연산 ((가) 산술 연산)
- 데이터의 각 비트들 간에 대한 AND, OR, NOT, Exclusive-OR 등과 같은 연산 수행 ((라) 논리 연산)
- CPU와 외부 장치들 간에 데이터 이동을 위한 동작 ((마) 입출력 (I/O))
- 각 명령어의 실행 순서를 변경하는 연산 ((나) 프로그램 제어)

2. 다음 용어에 대해 간단히 설명해 보세요.

- 연산 코드 (오퍼레이션 코드, Operation Code, Op-code)
- 오퍼랜드 (Operand)

	> 연산 코드 : CPU에서 수행될 연산을 지정해준다 (e.g. LOAD, ADD, JUMP ...)
	오퍼랜드 : 연산을 수행하는 데 필요한 데이터 혹은 주소를 나타낸다.

3. 다음 설명에 대해 맞으면 O, 틀리면 X 하세요. 

- 명령어는 CPU가 한 번에 처리할 수 있는 비트의 수로 처리된다. (O/X)

    > (O)
    → Word 라고 하는데, 크기는 컴퓨터 종류마다 달라서 정해져 있지 않다.

- 명령어를 구성하는 비트는 용도에 따라 몇 개의 필드 (Field) 로 나눠진다. 이 때 연산 코드 (Op-code)와 오퍼랜드 (Operand) 필드는 하나씩만 사용된다. (O/X)

    > (X) 
    → 오퍼랜드 (Operand)는 컴퓨터의 처리 능력에 따라 여러 개로 구성된다. 각 연산은 1~2개의 입력 오퍼랜드들과 1개의 결과 오퍼랜드를 가질 수 있다. 
    데이터는 CPU 레지스터나 기억장치에 위치한다.

- 명령어 형식 (instruction format) 은 명령어를 구성하는 필드의 종류&개수&배치 방식, 필드 당 비트 수를 정의한 형식이다. (O/X)

    > (O)

- 3-주소 명령어를 사용하면 프로그램이 짧아진다. (O/X)

    > (O)
    → 레지스터의 수와 기억장치 용량이 고정된 상태에서 3-주소 명령어 형식을 사용하면 명령어의 비트 수가 늘어진다. 결과적으로 프로그램을 저장하기 위한 기억장치 용량을 크게 줄어들지 않으며, 명령어 해독 과정이 더 복잡해지는 단점도 있다. 

4. 16비트 CPU는 한 번에 16비트 단위의 데이터 처리가 가능하고, CPU의 명령어 길이도 16비트입니다. 
주어진 명령어 형식을 따른다고 할 때, 빈칸을 알맞게 채워보세요.  

- 1-주소 명령어 (1-address instruction)에서 연산 코드는 4비트, 오퍼랜드는 12비트다.   
연산 종류는 `___`가지다.

    > 4비트니까 2<sup>4</sup> = `16`가지다.

- 2-주소 명령어에서 연산 코드는 4비트, 오퍼랜드1은 4비트, 오퍼랜드2는 8비트다. 오퍼랜드1만 레지스터다.  
연산의 종류는 (1) `___`가지,   
레지스터의 개수는 (2) `___`개,  
기억장치 주소 영역의 범위는 (3) `___` ~ `___-1`,  
데이터의 표현 범위는 (4) `___` ~ `___-1` 다.

    > 2-주소 명령어에서 연산 코드는 4비트, 오퍼랜드1은 4비트, 오퍼랜드2는 8비트다. 오퍼랜드1만 레지스터다. 
    연산의 종류는 (1) 2<sup>4</sup> = `16`가지,   
	레지스터의 개수는 (2) 2<sup>4</sup> = `16`개,   
	기억장치 주소 영역의 범위는 (3) `0` ~ `(2<sup>8</sup>-1)`,   
	데이터의 표현 범위는 (4) `-2<sup>7</sup>` ~ `(2<sup>7</sup>-1)` 다.  

</details>
<br><br>

### 2.4 명령어 세트 - 주소지정방식　　	`kukim`

#### 문제1
**3-주소 명령어의 장점에 해당하는 것은?**
- 가. 명령어 길이가 짧다.
- 나. 프로그램 길이가 짧아진다.
- 다. 임시저장장소가필요하다.
- 라. 주소지정 할수 있는 기억장치 주소 영역이 증가한다

#### 문제2
**간접 주소지정 방식을 사용하는 명령어는 실행 사이클 동안에 기억장치를 몇 번액세스하는가?**
- 가.한번 
- 나. 두번
- 다. 세번
- 라. 액세스하지 않는다.

#### 문제3
**아래 그림은 CPU 내부 레지스터들과 주기억장치에 그림과 같은 값들이 저장되어 있다고 가정하자.**  
**CPU 레지스터 및 각 기억 장소의 폭(width)은 16비트이며， 그림에서 모든 값들은 편의상 10진수로 표시하였다.**  
**아래의 문제에 답하시오.**  
![https://user-images.githubusercontent.com/57086195/101271734-df0ba000-37c8-11eb-9ed6-46a947f6d8ec.png](https://user-images.githubusercontent.com/57086195/101271734-df0ba000-37c8-11eb-9ed6-46a947f6d8ec.png)

##### 3.1
1. 직접 주소지정 방식을 사용하는 명령어의 주소 필드(A)에 저장된 내용이 150일때， 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라.

2. 명렁어 길이가 16비트이고 연산 코드가 5비트라면， 이 명령어에 의해 직접 주소지정 될 수 있는 기억장치 용량은 얼마인가?

##### 3.2
1. 간접 주소지정 방식을 사용하는 명령어의 주소 필드μ)에 저장된 내용이 ‘172’라고 가정했을 때， 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라


##### 3.3
- 조건 : 레지스터 R은 R2이다.
1. 레지스터 주소지정 방식이 사용된다면， 연산 처리 과정에서 어떤 데이터가 사용될 것인가?
2. 레지스터 간접 주소지정 방식이 사용된다면， 어떤 데이터가 사용될 것인가?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### 문제1
**3-주소 명령어의 장점에 해당하는 것은?**
- 가. 명령어 길이가 짧다.
- **나. 프로그램 길이가 짧아진다.**
- 다. 임시저장장소가필요하다.
- 라. 주소지정 할수 있는 기억장치 주소 영역이 증가한다

#### 문제2
**간접 주소지정 방식을 사용하는 명령어는 실행 사이클 동안에 기억장치를 몇 번액세스하는가?**
- 가.한번 
- **나. 두번**
- 다. 세번
- 라. 액세스하지 않는다.
- 해설 : 간접 주소지정 방식은 오퍼랜드가 가르키고있는 메모리주소로 접근하고 , 접근한 메모리 주소의 값이 메모리이기에 그 주소로 다시 접근한다.

#### 문제3
**아래 그림은 CPU 내부 레지스터들과 주기억장치에 그림과 같은 값들이 저장되어 있다고 가정하자. 여기서， CPU 레지스터 및 각 기억 장소의 폭(width)은 16비트이며， 그림에서 모든 값들은 편의상 10진수로 표시하였다.**
![https://user-images.githubusercontent.com/57086195/101271734-df0ba000-37c8-11eb-9ed6-46a947f6d8ec.png](https://user-images.githubusercontent.com/57086195/101271734-df0ba000-37c8-11eb-9ed6-46a947f6d8ec.png)

##### 3.1
1. 직접 주소지정 방식을 사용하는 명령어의 주소 필드(A)에 저장된 내용이 150일때， 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라.
- 정답 : '1234'
- 해설 : EA = 150이므로， 기억장치 150번지에 저장된 데이터 ‘1234'가 인출된다.

2. 명렁어 길이가 16비트이고 연산 코드가 5비트라면， 이 명령어에 의해 직접 주소지정 될 수 있는 기억장치 용량은 얼마인가?
- 정답 : 4096Byte = 2^11 * 2byte
- 해설 : 주소 필드가 11비트이므로， 직접 주소지정 할 수 있는 기억장치 용량은 2^11 = 2048 단어가 된다. 그런데 각 기억 장소에 저장되는 데이터의 비트 수가 16비트 (2바이트)이므로， 기억장치 용량은 4096바이트로 표현할 수도 있다.

![https://user-images.githubusercontent.com/57086195/101271736-e632ae00-37c8-11eb-8a92-940904c7d5ea.png](https://user-images.githubusercontent.com/57086195/101271736-e632ae00-37c8-11eb-8a92-940904c7d5ea.png)

##### 3.2
1. 간접 주소지정 방식을 사용하는 명령어의 주소 필드μ)에 저장된 내용이 ‘172’라고 가정했을 때， 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라
- 정답 : 3256
- 해설 : EA는 그림 2-24의 기억장치 172번지에 저장되어 있는 ‘202’이다. 따라서 명령어 실행에 사용될 데이터로는 기억장치 202번지에 저장되어 있는‘3256’이 인출된다.

![https://user-images.githubusercontent.com/57086195/101271741-f34f9d00-37c8-11eb-977e-d4a807a9f8d5.png](https://user-images.githubusercontent.com/57086195/101271741-f34f9d00-37c8-11eb-977e-d4a807a9f8d5.png)

##### 3.3
- 레지스터 R은 R2라고 가정한다.
1. 레지스터 주소지정 방식이 사용된다면， 연산 처리 과정에서 어떤 데이터가 사용될 것인가?
- 정답 :  R2에 저장되어 있는 데이터 ‘151’이 사용된다.
2. 레지스터 간접 주소지정 방식이 사용된다면， 어떤 데이터가 사용될 것인가?
- 정답 :  기억장치 151번지에 저장되어 있는 데이터 ‘5678’이 사용된다.

![https://user-images.githubusercontent.com/57086195/101271784-58a38e00-37c9-11eb-8a5e-81be3b313563.png](https://user-images.githubusercontent.com/57086195/101271784-58a38e00-37c9-11eb-8a5e-81be3b313563.png)

</details>
<br><br>

### 2.4 명령어 세트 - 상용프로세서 (간단히)　　	`mihykim`

#### [문제1]<br>다음 중에서 RISC 프로세서의 특징이 아닌 것은? (기본 2.21번)
- 가. 대부분 명령어들의 길이가 동일하다.
- 나. 주소지정 방식이 매우 다양한다.
- 다. CPU가 수행할 수 있는 연산의 종류가 적다.
- 라. 명령어의 수가 최소화 되었다.

#### [문제2]<br>다음은 맥북을 살지 고민한다는 secho의 고민을 듣고 컴퓨터구조 스터디원들이 함께 토론내용입니다. 대화 내용을 읽고 질문에 답해주세요.
- __문제2-1__ 다음 중 틀린 말을 한 사람이 있을까요? 있다면 누구일까요? (정답자 1등 +100점)
  - 참고용어
    - CISC[씨스크] : Complex Instruction Set Computer
    - RISC[리스크] Reduced Instruction Set Computer
    - ARM[암] Acorn RISC Machine / Advanced RISC Machine
    - 로제타 : 인텔 칩에서 실행되게끔 만들어진 기존 애플리케이션이 실행하기 위해 개발된 프로그램/에뮬레이터
- __문제2-2__ 결국 secho는 맥북을 사기로 결정했을까요? (정답자 전원 +100점)

---
`secho`: 저 새로나온 맥북을 살까 고민 중이에요 🤔

`taelee`: ARM 프로세서 탑재해서 나온거 말씀하시는거죠? '애플실리콘 M1' 이게 자체설계 ARM 프로세서래요.

`gaekim`: 오! 저도 출시기사 보고 검색해봤는데 'ARM'에 'R'이 저희 컴퓨터구조 스터디에 나온 `RISC`를 의미하는 거더라고요.🙄

`jakang`: 애플의 행보를 보면 `RISC`가 확실히 대세인가봐요. 회로 복잡도 증가 및 성능 한계를 극복하는 방법으로 명령어 수를 최소화하는 트렌드에 맞는거 같아요.

`kycho`: 사실 이전에는 이것저것 처리할 수 있는 `CISC`가 인기였어요. 😏

`daelee`: 맞아요. 1970~80년대에는 더 적은 트랜지스터로 더 복잡한 명령어도 빨리 소화할 수 있다는 점이 마케팅 포인트였대요. `RISC`에서 지루하게 명령어 4줄을 쳐야한다면 `CISC`에서는 단 1줄로 칠 수 있다! 이런식으로요.

`jehong`: 인텔, AMD는 `CISC` 방식을, IBM은 `RISC` 방식을 따랐어요. ARM사는 아키텍처 개발만 하고 직접 제조는 거의 안한다고 해요. 1978년 인텔 8086가 시작이었고 1999년 경쟁사인 AMD에서 발표한 AMD64가 사실상 x86의 표준이 되었다고 해요.🧐

`mihykim`: x86이라고 하시면 인텔에서 개발한 86비트 아키텍쳐를 말씀하시는거죠? 2000년대까지 승자는 `CISC`라 수 있겠지만, 보안·발열이슈로 앞으로 어떻게 될지는 지켜봐야할 것 같아요. 

`sancho`: 음, 제가 보기엔 맥북 특히 맥북프로를 사기에는 적합하지 않은 타이밍 같아요. 마이크로소프트의 서피스 프로, 삼성의 갤럭시북 등의 제품들도 ARM으로 플랫폼을 전환하려고 했었는데 하나 같이 애플리케이션 호환성이 좋지 못하다는 이유로 히트를 치지 못했어요. 😅

`kukim`: 제 생각도 그래요. 대부분의 애플리케이션이 x86 아키텍처를 기반으로 하고 있는 상황이고, 일부 x86 기반 프로그램들은 로제타2를 거쳐서 성능 손실이 날 수 있다고도 해요.

`yeha`: 앗 그렇군요. 하지만, 그래도 애플 생태계에 있는 어플리케이션만 주로 사용한다면 괜찮을 것 같기도 해요.🤗

`yeosong`: 저도 공감해요. 게다가 전력소모가 상당히 적다는 강력한 장점이 있는 걸요. 맥북의 고전적인 발열 문제도 없다고 반응이 좋아요.

`hylee`: (스읍-) 애플은 앞으로도 ARM을 고수할 것 같네요. 시장반응도 나쁘지 않고 자체설계 ARM 프로세서는 애플이 필요한대로 칩을 고칠 수 있는데 따로 로열티를 내지 않아도 되니 얼마나 좋겠어요.😎

`secho`: 흠.. 여러모로 고민이 되는군요... 하루만 더 생각해보고 마음을 정해야겠어요! 모두 같이 고민해주셔서 감사합니다!

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

#### [문제1]<br>다음 중에서 RISC 프로세서의 특징이 아닌 것은? (기본 2.21번)__
- 나. 주소지정 방식이 매우 다양한다. > 다양하지 않다!

#### [문제2]<br>다음은 맥북을 살지 고민한다는 secho의 고민을 듣고 컴퓨터구조 스터디원들이 함께 토론을 나눈 내용입니다.
- __문제2-1__ 다음 중 틀린 말을 한 사람은 누구일까요? (1등 +100점)
  - mihykim : x86은 32비트. 인텔에서 1978년에 개발한 인텔 8086에 적용된 아키텍쳐이자, 그 호환 프로세서 또는 후속작을 이르는 말
- __문제2-2__ 결국 secho는 맥북을 사기로 결정했을까요? (정답자 전원 +100점)
  - 정답은 secho님께..

https://www.youtube.com/watch?v=vbkFfo7w3II

</details>
<br><br>
