## 🦄 CPU의 기본 구성 및 명령어 세트 (4 / 13회차)
<br>

### 2.1 CPU의 기본 구조　　　　	`secho`

0번

다음은 기억장치에 저장된 명령어들을 실행함으로써 프로그램을 수행시키는 CPU의 동작과정이다.

순서에 맞게 나열해주세요.

가. 데이터 인출

나. 데이터 저장

다. 명령어 인출

라 데이터 처리

마 명령어 해독



`__`와 `__`는 공통적으로 수행되지만 `___, ___, ___`는 필요한 경우에만 수행한다.



1번 

빈칸에 알맞은 답을 채워주시고 간단한 설명도 작성해주세요.

CPU는 `_____`,`_____`,`_____` 으로 구성된다.



2번

보기를 보고 알맞은 답을 채워주세요

`가장 느리고, 가장 빠르고,  범용 레지스터, 특수기능 레지스터, 제어유닛, STORE, JUMP, IR, AR, VR, XR, MR MAR, MDR, MRI, PC, UCC, KCC, AC, SP, HP`,

CPU내부의 다양한 레지스터들의 집합인 레지스터 세트는 액세스 속도가 기억장치들 중 `1) _____`,

 종류로는  크게 `2) ________`와 `3) ________`가 있다.

`2)____`에는 4)`__`,`__`,`__`,`__`,`___`,`___`으로 이루어져있다





3번

다음은 CPU 내부 구조에 대한 대화입니다.

대화내용을 읽고 틀리게 말한 사람을 고르세요

![](https://images.velog.io/images/secho/post/56f382f4-05ba-48d3-9d81-001bda2a7ba9/image.png)



Kukim : 왼쪽 네모그림 안에있는 구성요소들이 CPU의 내부 요소야 바로 ALU, 레지스터 셋, 제어유닛이 포함되어있지.

Daelee : 아 그렇구나 PC위에 있는 +는 뭐야?

Yeosong : 그건 내가 얘기해줄게, PC는 이전에 인출했던 명령어 주소값을 가진 레지스터인데 명령어가 인출된 이후에 자동적으로 주소값이 1씩 증가되어서 가장 최근에 수행된 명령어 주소값을 가리키게 돼

Jakang : 아하 그렇구나 어 보니까 CPU Internal Bus는  CPU 내부에서만 사용하고 외부랑 직접적으로 연결이 되어있지 않네? 왜 그렇지? 그러면 어떻게 외부랑 접속될 수 있어?

Taelee : 그건 CPU 내부 처리속도와 외부 처리속도랑 차이가 있기 때문이야. 그래서 직접 연결하지 않고 간접적으로 버퍼 레지스터인 MDR, MAR를 통해 시스템 버스와 접속해.

Jehong : 아항 어라 근데 또 보니까 Address Bus는 Data Bus와 다르게 단방향이네? 왜지?

Taelee : Address Bus가 단방향인 이유는 CPU로부터 메모리에게 주소값을 전송하지만, 반대로의 전송은 필요가 없기 때문이야



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

0번

다음은 기억장치에 저장된 명령어들을 실행함으로써 프로그램을 수행시키는 CPU의 동작과정이다.

순서에 맞게 나열해주세요.

가. 데이터 인출

나. 데이터 저장

다. 명령어 인출

라 데이터 처리

마 명령어 해독



`다`와 `마`는 공통적으로 수행되지만 `가, 나, 라`는 필요한 경우에만 수행한다.

명령어인출과 해독은 공통적이지만 데이터 인출, 처리, 저장단계는 데이터가 필요한 경우에만 수행되기 때문(명령어 실행을 위한 데이터가 필요없는 경우도 있기 때문에.)



1번

CPU는 `ALU`,`레지스터 셋`,`제어유닛` 으로 구성된다.

- ALU : CPU 내부에서 산술 및 논리 연산을 수행하는 하드웨어 모듈
- 레지스터 셋: CPU 내부의 다양한 레지스터들의 집합.
  - CPU내부에서 처리되기 때문에 액세스 속도가 컴퓨터 기억장치들 중에서 가장 빠름
  - CPU내의 한정된 영역에 넣어야 하기 때문에 제한적임
- 제어유닛 : 명령어의 연산코드(Op-code)를 해석하고 그것을 실행하기 위한 제어 신호들을 순차적으로 발생시키는 하드웨어 모듈
  - 명령어 실행에 필요한 각 정보들의 전송 통로 방향을 지정
  - CPU 내부 요소들과 시스템 구성 요소들의 동작시간도 결정해줌

2번

보기를 보고 알맞은 답을 채워주세요

`가장 느리고, 가장 빠르고,  범용 레지스터, 특수기능 레지스터, 제어유닛, STORE, JUMP, IR, AR, VR, XR, MR MAR, MDR, MRI, PC, UCC, KCC, AC, SP, HP`,

CPU내부의 다양한 레지스터들의 집합인 레지스터 세트는 액세스 속도가 기억장치들 중 `1) 가장 빠르고`,

 종류로는  크게 `2) 특수기능 레지스터`와 `3) 범용 레지스터`가 있다.

`2)특수기능 레지스터`에는 4) `PC`,`IR`,`AC`,`SP`,`MAR`,`MDR`으로 이루어져있다



3번

다음은 CPU 내부 구조에 대한 대화입니다.

대화내용을 읽고 틀리게 말한 사람을 고르세요

![](https://images.velog.io/images/secho/post/56f382f4-05ba-48d3-9d81-001bda2a7ba9/image.png)



Kukim : 왼쪽 네모그림 안에있는 구성요소들이 CPU의 내부 요소야 바로 ALU, 레지스터 셋, 제어유닛이 포함되어있지.

Daelee : 아 그렇구나 PC위에 있는 +는 뭐야?

Yeosong : 그건 내가 얘기해줄게, PC는 이전에 인출했던 명령어 주소값을 가진 레지스터인데 명령어가 인출된 이후에 자동적으로 주소값이 1씩 증가되어서 가장 최근에 수행된 명령어 주소값을 가리키게 돼

Jakang : 아하 그렇구나 어 보니까 CPU Internal Bus는  CPU 내부에서만 사용하고 외부랑 직접적으로 연결이 되어있지 않네? 왜 그렇지? 그러면 어떻게 외부랑 접속될 수 있어?

Taelee : 그건 CPU 내부 처리속도와 외부 처리속도랑 차이가 있기 때문이야. 그래서 직접 연결하지 않고 간접적으로 버퍼 레지스터인 MDR, MAR를 통해 시스템 버스와 접속해.

Jehong : 아항 어라 근데 또 보니까 Address Bus는 Data Bus와 다르게 단방향이네? 왜지?

Taelee : Address Bus가 단방향인 이유는 CPU로부터 메모리에게 주소값을 전송하지만, 반대로의 전송은 필요가 없기 때문이야



Yeosong: 이전이 아니라 다음에 인출할 명령어 주소값을 가진 레지스터임, 명령어 인출 후에는 1씩증가되는게 아니라 컴퓨터가 한번에 처리할 수 있는 크기, 즉 워드 크기만큼 증가한다.



</details>
<br><br>

### 2.4 명령어 세트 - 연산의 종류, 명령어형식　　　　　	`yeha`

1. 보기에 있는 연산과 연산에 대한 설명을 알맞게 짝지어 보세요. 

```c
(가) 산술 연산 (나) 프로그램 제어 (다) 데이터 전송 (라) 논리 연산 (마) 입출력 (I/O) 
```

- 레지스터와 레지스터 간, 레지스터와 기억장치 간, 기억장치와 기억장치 간에 데이터를 이동시키는 동작 (___)
- 덧셈, 뺄셈, 곱셈, 나눗셈과 같은 기본적인 산술 연산 (___)
- 데이터의 각 비트들 간에 대한 AND, OR, NOT, Exclusive-OR 등과 같은 연산 수행 (___)
- CPU와 외부 장치들 간에 데이터 이동을 위한 동작 (___)
- 각 명령어의 실행 순서를 변경하는 연산 (___)

2. 다음 용어에 대해 간단히 설명해 보세요.

- 연산 코드 (오퍼레이션 코드, Operation Code, Op-code)
- 오퍼랜드 (Operand)

3. 다음 설명에 대해 맞으면 O, 틀리면 X 하세요. 

- 명령어는 CPU가 한 번에 처리할 수 있는 비트의 수로 처리된다. (O/X)

- 명령어를 구성하는 비트는 용도에 따라 몇 개의 필드 (Field) 로 나눠진다. 이 때 연산 코드 (Op-code)와 오퍼랜드 (Operand) 필드는 하나씩만 사용된다. (O/X)

- 명령어 형식 (instruction format) 은 명령어를 구성하는 필드의 종류&개수&배치 방식, 필드 당 비트 수를 정의한 형식이다. (O/X)

4. 16비트 CPU는 한 번에 16비트 단위의 데이터 처리가 가능하고, CPU의 명령어 길이도 16비트입니다. 
주어진 명령어 형식을 따른다고 할 때, 빈칸을 알맞게 채워보세요.  

- 1-주소 명령어 (1-address instruction)에서 연산 코드는 4비트, 오퍼랜드는 12비트다.   
연산 종류는 (___)가지다.


- 2-주소 명령어에서 연산 코드는 4비트, 오퍼랜드1은 4비트, 오퍼랜드2는 8비트다. 오퍼랜드1만 레지스터다.  
연산의 종류는 (1) (___)가지,   
레지스터의 개수는 (2) (___)개,  
기억장치 주소 영역의 범위는 (3) (___) ~ (___-1),  
데이터의 표현 범위는 (4) (___) ~ (___-1) 다.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
	1. 보기에 있는 연산과 연산에 대한 설명을 알맞게 짝지어 보세요. 

```c
(가) 산술 연산 (나) 프로그램 제어 (다) 데이터 전송 (라) 논리 연산 (마) 입출력 (I/O) 
```

- 레지스터와 레지스터 간, 레지스터와 기억장치 간, 기억장치와 기억장치 간에 데이터를 이동시키는 동작 ((다) 데이터 전송)
- 덧셈, 뺄셈, 곱셈, 나눗셈과 같은 기본적인 산술 연산 ((가) 산술 연산)
- 데이터의 각 비트들 간에 대한 AND, OR, NOT, Exclusive-OR 등과 같은 연산 수행 ((라) 논리 연산)
- CPU와 외부 장치들 간에 데이터 이동을 위한 동작 ((마) 입출력 (I/O))
- 각 명령어의 실행 순서를 변경하는 연산 ((나) 프로그램 제어)

2. 다음 용어에 대해 간단히 설명해 보세요.

- 연산 코드 (오퍼레이션 코드, Operation Code, Op-code)
- 오퍼랜드 (Operand)

	> 연산 코드 : CPU에서 수행될 연산을 지정해준다 (e.g. LOAD, ADD, JUMP ...)
	오퍼랜드 : 연산을 수행하는 데 필요한 데이터 혹은 주소를 나타낸다.

3. 다음 설명에 대해 맞으면 O, 틀리면 X 하세요. 

- 명령어는 CPU가 한 번에 처리할 수 있는 비트의 수로 처리된다. (O/X)

    > (O)
    → Word 라고 하는데, 크기는 컴퓨터 종류마다 달라서 정해져 있지 않다.

- 명령어를 구성하는 비트는 용도에 따라 몇 개의 필드 (Field) 로 나눠진다. 이 때 연산 코드 (Op-code)와 오퍼랜드 (Operand) 필드는 하나씩만 사용된다. (O/X)

    > (X) 
    → 오퍼랜드 (Operand)는 컴퓨터의 처리 능력에 따라 여러 개로 구성된다. 각 연산은 1~2개의 입력 오퍼랜드들과 1개의 결과 오퍼랜드를 가질 수 있다. 
    데이터는 CPU 레지스터나 기억장치에 위치한다.

- 명령어 형식 (instruction format) 은 명령어를 구성하는 필드의 종류&개수&배치 방식, 필드 당 비트 수를 정의한 형식이다. (O/X)

    > (O)

4. 16비트 CPU는 한 번에 16비트 단위의 데이터 처리가 가능하고, CPU의 명령어 길이도 16비트입니다. 
주어진 명령어 형식을 따른다고 할 때, 빈칸을 알맞게 채워보세요.  

- 1-주소 명령어 (1-address instruction)에서 연산 코드는 4비트, 오퍼랜드는 12비트다.   
연산 종류는 (___)가지다.

    > 4비트니까 2<sup>4</sup> = 16가지다.

- 2-주소 명령어에서 연산 코드는 4비트, 오퍼랜드1은 4비트, 오퍼랜드2는 8비트다. 오퍼랜드1만 레지스터다.  
연산의 종류는 (1) (___)가지,   
레지스터의 개수는 (2) (___)개,  
기억장치 주소 영역의 범위는 (3) (___) ~ (___-1),  
데이터의 표현 범위는 (4) (___) ~ (___-1) 다.
    > 2-주소 명령어에서 연산 코드는 4비트, 오퍼랜드1은 4비트, 오퍼랜드2는 8비트다. 오퍼랜드1만 레지스터다. 
    연산의 종류는 (1) 2<sup>4</sup> = 16가지, 
	레지스터의 개수는 (2) 2<sup>4</sup> = 16개, 
	기억장치 주소 영역의 범위는 (3) 0 ~ (2<sup>8</sup>-1), 
	데이터의 표현 범위는 (4) -2<sup>7</sup> ~ (2<sup>7</sup>-1) 다.

</details>
<br><br>

### 2.4 명령어 세트 - 주소지정방식　　	`kukim`

#### 문제1
**3-주소 명령어의 장점에 해당하는 것은?**
- 가. 명령어 길이가 짧다.
- 나. 프로그램 길이가 짧아진다.
- 다. 임시저장장소가필요하다.
- 라. 주소지정 할수 있는 기억장치 주소 영역이 증가한다

#### 문제2
**간접 주소지정 방식을 사용하는 명령어는 실행 사이클 동안에 기억장치를 몇 번액세스하는가?**
- 가.한번 
- 나. 두번
- 다. 세번
- 라. 액세스하지 않는다.

#### 문제3
**아래 그림은 CPU 내부 레지스터들과 주기억장치에 그림과 같은 값들이 저장되어 있다고 가정하자.**  
**CPU 레지스터 및 각 기억 장소의 폭(width)은 16비트이며， 그림에서 모든 값들은 편의상 10진수로 표시하였다.**  
**아래의 문제에 답하시오.**  
![https://user-images.githubusercontent.com/57086195/101271734-df0ba000-37c8-11eb-9ed6-46a947f6d8ec.png](https://user-images.githubusercontent.com/57086195/101271734-df0ba000-37c8-11eb-9ed6-46a947f6d8ec.png)

##### 3.1
1. 직접 주소지정 방식을 사용하는 명령어의 주소 필드(A)에 저장된 내용이 150일때， 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라.

2. 명렁어 길이가 16비트이고 연산 코드가 5비트라면， 이 명령어에 의해 직접 주소지정 될 수 있는 기억장치 용량은 얼마인가?

##### 3.2
1. 간접 주소지정 방식을 사용하는 명령어의 주소 필드μ)에 저장된 내용이 ‘172’라고 가정했을 때， 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라


##### 3.3
- 조건 : 레지스터 R은 R2이다.
1. 레지스터 주소지정 방식이 사용된다면， 연산 처리 과정에서 어떤 데이터가 사용될 것인가?
2. 레지스터 간접 주소지정 방식이 사용된다면， 어떤 데이터가 사용될 것인가?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### 문제1
**3-주소 명령어의 장점에 해당하는 것은?**
- 가. 명령어 길이가 짧다.
- **나. 프로그램 길이가 짧아진다.**
- 다. 임시저장장소가필요하다.
- 라. 주소지정 할수 있는 기억장치 주소 영역이 증가한다

#### 문제2
**간접 주소지정 방식을 사용하는 명령어는 실행 사이클 동안에 기억장치를 몇 번액세스하는가?**
- 가.한번 
- **나. 두번**
- 다. 세번
- 라. 액세스하지 않는다.
- 해설 : 간접 주소지정 방식은 오퍼랜드가 가르키고있는 메모리주소로 접근하고 , 접근한 메모리 주소의 값이 메모리이기에 그 주소로 다시 접근한다.

#### 문제3
**아래 그림은 CPU 내부 레지스터들과 주기억장치에 그림과 같은 값들이 저장되어 있다고 가정하자. 여기서， CPU 레지스터 및 각 기억 장소의 폭(width)은 16비트이며， 그림에서 모든 값들은 편의상 10진수로 표시하였다.**
![https://user-images.githubusercontent.com/57086195/101271734-df0ba000-37c8-11eb-9ed6-46a947f6d8ec.png](https://user-images.githubusercontent.com/57086195/101271734-df0ba000-37c8-11eb-9ed6-46a947f6d8ec.png)

##### 3.1
1. 직접 주소지정 방식을 사용하는 명령어의 주소 필드(A)에 저장된 내용이 150일때， 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라.
- 정답 : '1234'
- 해설 : EA = 150이므로， 기억장치 150번지에 저장된 데이터 ‘1234'가 인출된다.

2. 명렁어 길이가 16비트이고 연산 코드가 5비트라면， 이 명령어에 의해 직접 주소지정 될 수 있는 기억장치 용량은 얼마인가?
- 정답 : 4096Byte = 2^11 * 2byte
- 해설 : 주소 필드가 11비트이므로， 직접 주소지정 할 수 있는 기억장치 용량은 2^11 = 2048 단어가 된다. 그런데 각 기억 장소에 저장되는 데이터의 비트 수가 16비트 (2바이트)이므로， 기억장치 용량은 4096바이트로 표현할 수도 있다.

![https://user-images.githubusercontent.com/57086195/101271736-e632ae00-37c8-11eb-8a92-940904c7d5ea.png](https://user-images.githubusercontent.com/57086195/101271736-e632ae00-37c8-11eb-8a92-940904c7d5ea.png)

##### 3.2
1. 간접 주소지정 방식을 사용하는 명령어의 주소 필드μ)에 저장된 내용이 ‘172’라고 가정했을 때， 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라
- 정답 : 3256
- 해설 : EA는 그림 2-24의 기억장치 172번지에 저장되어 있는 ‘202’이다. 따라서 명령어 실행에 사용될 데이터로는 기억장치 202번지에 저장되어 있는‘3256’이 인출된다.

![https://user-images.githubusercontent.com/57086195/101271741-f34f9d00-37c8-11eb-977e-d4a807a9f8d5.png](https://user-images.githubusercontent.com/57086195/101271741-f34f9d00-37c8-11eb-977e-d4a807a9f8d5.png)

##### 3.3
- 레지스터 R은 R2라고 가정한다.
1. 레지스터 주소지정 방식이 사용된다면， 연산 처리 과정에서 어떤 데이터가 사용될 것인가?
- 정답 :  R2에 저장되어 있는 데이터 ‘151’이 사용된다.
2. 레지스터 간접 주소지정 방식이 사용된다면， 어떤 데이터가 사용될 것인가?
- 정답 :  기억장치 151번지에 저장되어 있는 데이터 ‘5678’이 사용된다.

![https://user-images.githubusercontent.com/57086195/101271784-58a38e00-37c9-11eb-8a5e-81be3b313563.png](https://user-images.githubusercontent.com/57086195/101271784-58a38e00-37c9-11eb-8a5e-81be3b313563.png)

</details>
<br><br>

### 2.4 명령어 세트 - 상용프로세서 (간단히)　　	`mihykim`

#### 문제1
__다음 중에서 RISC 프로세서의 특징이 아닌 것은? (기본 2.21번)__
- 가. 대부분 명령어들의 길이가 동일하다.
- 나. 주소지정 방식이 매우 다양한다.
- 다. CPU가 수행할 수 있는 연산의 종류가 적다.
- 라. 명령어의 수가 최소화 되었다.

#### 문제2
- RISC
- CISC
- ARM
- AMD
- 인텔
- x86
- x64

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
https://www.youtube.com/watch?v=vbkFfo7w3II

</details>
<br><br>
