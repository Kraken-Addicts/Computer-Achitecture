## 🦄 I/O Device (12 / 13회차)





### 7.3 I/O 장치의 접속 - I/O제어　`gaekim`

+ 문제

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- 답지

</div>
</details>
<br><br>



### 7.3 I/O 장치의 접속 - I/O주소지정　`secho`

#### 1번

Programmed I/O방식이란 CPU가 I/O장치 상태를 반복적으로 검사하면서 동작을 처리하는  동작을 뜻합니다. 이 방식은 입출력 여부를 CPU가 반복적으로 확인하고, 전체 입출력이 완료되기 전까지 다른 작업을 할 수 없는 단점을 갖고 있습니다.

이 방식에서 사용되는 I/O장치의 주소지정방식에는 두 가지가 있는데요. 각각,

1. `M____I/O`

2. `I____-I/O`

라고 합니다.



#### 2번

빈칸과 질문에 대한 답을 작성해주세요.



1번그림 

![](https://images.velog.io/images/secho/post/64a83a02-331c-4116-998d-7187e0ae8424/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.33.01.png)

- I/O제어기 내의 레지스터들(`___ 레지스터` `__/__레지스터`) 에게 주소영역을 할당하는 `_________`  주소지정 방식이다.

- 메인메모리에 대한 명령어, 즉 어셈블리어를 I/O장치에 대해서 `따로 / 같이` 쓰기 때문에 프로그래밍이 `용이 / 불편` 하다.

- 기억장치 주소 영역을 거의 `__`비율에 가깝도록 메인메모리와 나누어 사용해 주소공간이 줄어든다는 단점이 존재한다.



2번그림

**O / X 문제**

![](https://images.velog.io/images/secho/post/90e18c3e-4e7f-4a29-8aaa-be881a24e22d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.41.25.png)

- I/O장치에 별도로 주소영역을 지정하는 isolated-I/O 이다. `O / X `

- 분리된 메모리영역사용으로 기억 장치 주소공간을 효율적으로 사용가능하지만, I/O에 접근하기 위해서 별도의 명령어를 사용해야한다. ` O / X `



**쿠키 타임**

![](https://images.velog.io/images/secho/post/27608b71-bca2-479d-8961-62e9079039cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.50.16.png)



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### 1번

Programmed I/O방식이란 CPU가 I/O장치 상태를 반복적으로 검사하면서 동작을 처리하는  동작을 뜻합니다. 이 방식은 입출력 여부를 CPU가 반복적으로 확인하고, 전체 입출력이 완료되기 전까지 다른 작업을 할 수 없는 단점을 갖고 있습니다.

이 방식에서 사용되는 I/O장치의 주소지정방식에는 두 가지가 있는데요. 각각,

1. `memory-mapped-I/O`

2. `Isolated-I/O`

라고 합니다.



#### 2번

빈칸과 질문에 대한 답을 작성해주세요.



1번그림 

![](https://images.velog.io/images/secho/post/64a83a02-331c-4116-998d-7187e0ae8424/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.33.01.png)

- I/O제어기 내의 레지스터들(`데이터 레지스터` `상태/제어레지스터`) 에게 주소영역을 할당하는 `memory-mapped io`  주소지정 방식이다.

- 메인메모리에 대한 명령어, 즉 어셈블리어를 I/O장치에 대해서 `따로 / |같이|` 쓰기 때문에 프로그래밍이 `|용이| / 불편` 하다.

- 기억장치 주소 영역을 거의 `절반``비율에 가깝도록 메인메모리와 나누어 사용해 주소공간이 줄어든다는 단점이 존재한다.



2번그림

**O / X 문제**

![](https://images.velog.io/images/secho/post/90e18c3e-4e7f-4a29-8aaa-be881a24e22d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.41.25.png)

- I/O장치에 별도로 주소영역을 지정하는 isolated-I/O 이다. `|O| / X `

- 분리된 메모리영역사용으로 기억 장치 주소공간을 효율적으로 사용가능하지만, I/O에 접근하기 위해서 별도의 명령어를 사용해야한다. ` |O| / X `



[출처](http://jidum.com/jidums/view.do?jidumId=467)

</div>
</details>
<br><br>



### 7.4 인터럽트를 이용한 I/O　`yeha`

+ 문제

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- 답지
> **다중 인터럽트(multiple interrupt) 방식**  
![image](https://user-images.githubusercontent.com/60090790/103475641-63663880-4df2-11eb-9932-6e93b1a97294.png)
: CPU에 I/O 컨트롤러들이 각각 연결(병렬 구현)되어 있다. 인터럽트를 누가 발생시켰는지 자동으로 알게 된다.   
하드웨어가 복잡하다. I/O장치들의 수가 CPU의 인터럽트 요구 입력 핀의 수에 의해 제한된다.  

> **데이지-체인(daisy-chain) 방식**  
![image](https://user-images.githubusercontent.com/60090790/103475643-77aa3580-4df2-11eb-8aea-ac272af7099f.png)
: 직렬 구현 방식
인터럽트를 요구한 I/O 장치는 CPU가 인터럽트를 받았다고 응답하는 INT A신호가 오는 즉시 **인터럽트 벡터**(interrupt vector, 고유 식별 (ID) 번호, 인터럽트 서비스 루틴의 시작 주소)**를 CPU로 보낸다**. 만약 인터럽트를 요구하지 않았다면 확인 신호를 다음 I/O 장치로 통과시킨다.    
신호 선이 적어서 하드웨어가 간단하다. 하지만 우선순위가 낮은 장치들이 매우 오랫동안 기다릴 수 있다.  
 
> **소프트웨어 폴링(software polling) 방식**  
![image](https://user-images.githubusercontent.com/60090790/103475647-85f85180-4df2-11eb-8b9f-baf8282601db.png)
: **CPU가** TEST I/O선을 이용해서 **누가 인터럽트를 요구했는지** I/O장치를 일일히 검사하는 방식이다.   
소프트웨어를 이용하고, 일일히 검사하기 때문에 처리 시간이 다소 오래 걸린다. 우선순위 변경이 용이하다.  

[문제1] '인터럽트를 이용한 I/O' 방식의 장점과 단점은 무엇인가요?  

> CPU는 인터럽트가 발생할 때만 Status Bit를 검사하므로 **남은 시간에 다른 일을 할 수 있다**.   
하지만 여전히 데이터 이동에 **CPU가 개입**해야 하고, 이동되는 데이터들이 CPU를 거쳐야 하는 문제점이 있어 DMA를 이용한 I/O 방식이 사용된다. 

[문제2] 인터럽트를 처리하기 위한 다음 방법들에 대하여 알맞은 설명을 짝지어 주세요.
```
(a) 다중 인터럽트(multiple interrupt) 방식 
(b) 데이지-체인(daisy-chain) 방식
(c) 소프트웨어 폴링(software polling) 방식
```
- 하드웨어가 가장 간단한 방식은 어떤 것인가요?  
- 우선순위를 쉽게 변경할 수 있는 방식은 어떤 것인가요?  
- 처리 속도가 가장 빠른 것은 어떤 방식인가요?  

> - 하드웨어가 가장 간단한 방식은 어떤 것인가요?  
=> **(b) 데이지-체인(daisy-chain) 방식**
> - 우선순위를 쉽게 변경할 수 있는 방식은 어떤 것인가요?  
=> **(c) 소프트웨어 폴링(software polling) 방식** 
> - 처리 속도가 가장 빠른 것은 어떤 방식인가요?  
=> **(a) 다중 인터럽트(multiple interrupt) 방식**

 
[문제3] 데이지-체인 방식으로 입터럽트를 요구한 장치를 찾아내는 방법에 관한 설명으로 잘못된 것은 다음 중 어느 것인가요?  
가. 모든 장치들이 직렬로 연결된다.  
나. 장치들의 우선순위가 고정된다.   
다. 접속할 수 있는 장치의 수가 CPU의 인터럽트 입력 핀의 수에 의해 제한된다.  
라. 인터럽트 벡터를 이용하여 장치의 ID를 CPU로 알려준다.  

> **다**. 접속할 수 있는 장치의 수가 CPU의 인터럽트 입력 핀의 수에 의해 제한된다.  
다중 인터럽트 방식에 대한 설명이다.  

[문제4] 소프트웨어 폴링 방식으로 이용한 인터럽트-구동 I/O의 단점은 다음 중 어느 것인가요?  
가. 처리 시간이 오래 걸린다.  
나. 하드웨어가 복잡하다.  
다. 우선순위가 고정된다.  
라. 연결될 수 있는 장치의 수가 제한된다.  

> **가**. 처리 시간이 오래 걸린다.  




</div>
</details>
<br><br>



### 7.5 DMA를 이용한 I/O　`kukim`


#### [문제1] O/X
- DMA를 이용한 I/O는 인터럽트-구동 I/O 방식과, 프로그램을 이용한 I/O방식 보다 더 효율적이라고 볼 수 없다. (O / X)

#### [문제2] 괄호를 채워주세요.
- 큰 데이터 블록을 전송하는 경우에는 CPU가 그 동작을 수행하는데 많은 시간을 소모해야 하며, 시스템 버스도 대부분의 시간 동안 그러한 I/O 동작들을 위해 사용될 수 밖에 없기 때문에 이러한 문제를 해결하기 위하여 (a)가 널리 사용되고 있다
- (a)란 CPU의 개입 없이 I/O 장치와 기억장치 사이에 데이터 전송을 수행하는 메커니즘을 말한다.
- (a) 방식을 사용하기 위해서는 시스템 버스에 (b)가 추가되어야 한다. (b)란 CPU 개입 없이 I/O 장치와 기억장치 간의 데이터 전송을 수행하는 (a) 동작을 지원하는 하드웨어 모듈이다.
- (b)는 가능한 한 CPU의 정상적인 동작을 방해하지 않으면서 시스템 버스를 사용하는데 이를 지칭하는 용어를 (c)라고 한다

#### [설명]
- 주기억장치 내의 어떤 데이터블록을 디스크에 저장하기 위한 DMA 제어기 작동 방식은 아래와 같다.

1. CPU가 DMA 제어기에게 명령을 보낸다.
2. DMA 제어기는 CPU로 BUS REQ 신호를 보낸다.
3. CPU가 DMA 제어기로 BUS GRANT 신호를 보낸다.
4. DMA 제어기가 버스를 사용하여 주기억장치로부터 데이터를 읽어서 디스크 제어기로 보낸다. (디스크에 저장)
5. 저장할 데이터가 남아 있다면 2~4번 까지 반복한다.
6. 모든 데이터들의 저장이 완료되면 CPU로 INTR 신호를 보낸다.

![DMA제어기내부구조](https://user-images.githubusercontent.com/57086195/103475139-c6090580-4ded-11eb-9ded-3e437ccde65e.png)

- 하나의 DMA 제어기에 직접 연결할 수 있는 I/O 제어기의 수가 제한되어있기 때문에 아래와 같이 구성되어 있다.

![DMA제어기2](https://user-images.githubusercontent.com/57086195/103475146-da4d0280-4ded-11eb-8375-72ec76931e65.png)

#### [문제3]
- DMA 제어기의 한계를 극복하기 위하여 사용하는 방식은 어느 것인가?
1.  I/O 프로세서
2. 다중 인터럽트
3. 프로그램을 이용한 I/O
4. 멀티플렉싱


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### [문제1] O/X
- DMA를 이용한 I/O는 인터럽트-구동 I/O 방식과, 프로그램을 이용한 I/O방식 보다 더 효율적이라고 볼 순 없다. (O / X)
- (X) 효율적이다. 왜냐하면 인터럽트와 프로그램을 이용한 I/O 방식은 CPU가 직접 개입해야하기 때문이다. ####[문제1]

#### [문제2] 괄호를 채워주세요.
- 큰 데이터 블록을 전송하는 경우에는 CPU가 그 동작을 수행하는데 많은 시간을 소모해야 하며, 시스템 버스도 대부분의 시간 동안 그러한 I/O 동작들을 위해 사용될 수 밖에 없기 때문에 이러한 문제를 해결하기 위하여 (a.직접기억장치액세스(Direct Memory Access: DMA)가 널리 사용되고 있다
- (a.DMA)란 CPU의 개입 없이 I/O 장치와 기억장치 사이에 데이터 전송을 수행하는 메커니즘을 말한다.
- (a. DMA) 방식을 사용하기 위해서는 시스템 버스에 (b. DMA 버스)가 추가되어야 한다. (b.DMA 제어기)란 CPU 개입 없이 I/O 장치와 기억장치 간의 데이터 전송을 수행하는 (a. DMA) 동작을 지원하는 하드웨어 모듈이다.
- (b. DMA 제어기)는 가능한 한 CPU의 정상적인 동작을 방해하지 않으면서 시스템 버스를 사용하는데 이를 지칭하는 용어를 (c. 사이클 스털링(cycle stealing) : CPU가 시스템 버스를 사용하지 않는 동안에 DMA 제어기가 버스를 사용함)라고 한다

#### [설명]
- 주기억장치 내의 어떤 데이터블록을 디스크에 저장하기 위한 DMA 제어기 작동 방식은 아래와 같다.

1. CPU가 DMA 제어기에게 명령을 보낸다.
2. DMA 제어기는 CPU로 BUS REQ 신호를 보낸다.
3. CPU가 DMA 제어기로 BUS GRANT 신호를 보낸다.
4. DMA 제어기가 버스를 사용하여 주기억장치로부터 데이터를 읽어서 디스크 제어기로 보낸다. (디스크에 저장)
5. 저장할 데이터가 남아 있다면 2~4번 까지 반복한다.
6. 모든 데이터들의 저장이 완료되면 CPU로 INTR 신호를 보낸다.

![DMA제어기내부구조](https://user-images.githubusercontent.com/57086195/103475139-c6090580-4ded-11eb-9ded-3e437ccde65e.png)

- 하나의 DMA 제어기에 직접 연결할 수 있는 I/O 제어기의 수가 제한되어있기 때문에 아래와 같이 구성되어 있다.

![DMA제어기2](https://user-images.githubusercontent.com/57086195/103475146-da4d0280-4ded-11eb-8375-72ec76931e65.png)

#### [문제3]
- DMA 제어기의 한계를 극복하기 위하여 사용하는 방식은 어느 것인가?
1.  I/O 프로세서
2. 다중 인터럽트
3. 프로그램을 이용한 I/O
4. 멀티플렉싱

- 정답 : 1. I/O 프로세서
- DMA 제어기의 한계는 데이터 전송에 문제가 있었다. I/O 장치들은 종류가 다양한 만큼 각각의 속도와, 제어 방법도 다양했다. 따라서 간단한 구조인 DMA 제어기로 지원하는 데는 한계가 있었다.
- 또한 디스크 쓰기 or 읽기 동작의 경우 데이터 블록의 크기가 512바이트 이상이었기 때문에 그 데이터들의 더 큰 임시 버퍼 공간이 필요했다. 따라서 이를 해결하기 위해 DMA 제어기를 확장시킨 I/O 프로세서(IOP)를 사용하고 있다. 이는 I/O 채널 이라고도 부른다.

![IOP](https://user-images.githubusercontent.com/57086195/103475191-695a1a80-4dee-11eb-9f41-c460c45adf3f.png)

</div>
</details>
<br><br>

