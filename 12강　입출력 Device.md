## 🦄 I/O Device (12 / 13회차)





### 7.3 I/O 장치의 접속 - I/O제어　`gaekim`

+ 문제

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- 답지

</div>
</details>
<br><br>



### 7.3 I/O 장치의 접속 - I/O주소지정　`secho`

#### 1번

Programmed I/O방식이란 CPU가 I/O장치 상태를 반복적으로 검사하면서 동작을 처리하는  동작을 뜻합니다. 이 방식은 입출력 여부를 CPU가 반복적으로 확인하고, 전체 입출력이 완료되기 전까지 다른 작업을 할 수 없는 단점을 갖고 있습니다.

이 방식에서 사용되는 I/O장치의 주소지정방식에는 두 가지가 있는데요. 각각,

1. `M____I/O`

2. `I____-I/O`

라고 합니다.



#### 2번

빈칸과 질문에 대한 답을 작성해주세요.



1번그림 

![](https://images.velog.io/images/secho/post/64a83a02-331c-4116-998d-7187e0ae8424/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.33.01.png)

- I/O제어기 내의 레지스터들(`___ 레지스터` `__/__레지스터`) 에게 주소영역을 할당하는 `_________`  주소지정 방식이다.

- 메인메모리에 대한 명령어, 즉 어셈블리어를 I/O장치에 대해서 `따로 / 같이` 쓰기 때문에 프로그래밍이 `용이 / 불편` 하다.

- 기억장치 주소 영역을 거의 `__`비율에 가깝도록 메인메모리와 나누어 사용해 주소공간이 줄어든다는 단점이 존재한다.



2번그림

**O / X 문제**

![](https://images.velog.io/images/secho/post/90e18c3e-4e7f-4a29-8aaa-be881a24e22d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.41.25.png)

- I/O장치에 별도로 주소영역을 지정하는 isolated-I/O 이다. `O / X `

- 분리된 메모리영역사용으로 기억 장치 주소공간을 효율적으로 사용가능하지만, I/O에 접근하기 위해서 별도의 명령어를 사용해야한다. ` O / X `



**쿠키 타임**

![](https://images.velog.io/images/secho/post/27608b71-bca2-479d-8961-62e9079039cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.50.16.png)



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### 1번

Programmed I/O방식이란 CPU가 I/O장치 상태를 반복적으로 검사하면서 동작을 처리하는  동작을 뜻합니다. 이 방식은 입출력 여부를 CPU가 반복적으로 확인하고, 전체 입출력이 완료되기 전까지 다른 작업을 할 수 없는 단점을 갖고 있습니다.

이 방식에서 사용되는 I/O장치의 주소지정방식에는 두 가지가 있는데요. 각각,

1. `memory-mapped-I/O`

2. `Isolated-I/O`

라고 합니다.



#### 2번

빈칸과 질문에 대한 답을 작성해주세요.



1번그림 

![](https://images.velog.io/images/secho/post/64a83a02-331c-4116-998d-7187e0ae8424/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.33.01.png)

- I/O제어기 내의 레지스터들(`데이터 레지스터` `상태/제어레지스터`) 에게 주소영역을 할당하는 `memory-mapped io`  주소지정 방식이다.

- 메인메모리에 대한 명령어, 즉 어셈블리어를 I/O장치에 대해서 `따로 / |같이|` 쓰기 때문에 프로그래밍이 `|용이| / 불편` 하다.

- 기억장치 주소 영역을 거의 `절반``비율에 가깝도록 메인메모리와 나누어 사용해 주소공간이 줄어든다는 단점이 존재한다.



2번그림

**O / X 문제**

![](https://images.velog.io/images/secho/post/90e18c3e-4e7f-4a29-8aaa-be881a24e22d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.41.25.png)

- I/O장치에 별도로 주소영역을 지정하는 isolated-I/O 이다. `|O| / X `

- 분리된 메모리영역사용으로 기억 장치 주소공간을 효율적으로 사용가능하지만, I/O에 접근하기 위해서 별도의 명령어를 사용해야한다. ` |O| / X `



[출처](http://jidum.com/jidums/view.do?jidumId=467)

</div>
</details>
<br><br>



### 7.4 인터럽트를 이용한 I/O　`yeha`

+ 문제

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- 답지

</div>
</details>
<br><br>



### 7.5 DMA를 이용한 I/O　`kukim`

+ 문제

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- 답지

</div>
</details>
<br><br>

