## 🦄 인터럽트/서브루틴/파이프라이닝 (6 / 13회차)
<br>

### 2.3 명령어 파이프라이닝 - 2단계　　	`jakang`

1번. 빈칸에 알맞은 답을 채워주세요

`1) ________` 이란 명령어를 실행하는데 사용되는 하드웨어를 여러 개의 독립적인 단계들로 분할하고, 그들로 하여금 동시에 서로 다른 명령어들을 처리하도록 함으로써 CPU의 성능을 높여지는 기술을 말한다.

2단계 명령어 파이프라인에서는 명령어를 실행하는 단계를 `2) ________`와 `3) ________`로 분리하여 구성할 수 있다.

2번. 다음 지문들의 참 거짓 여부를 표시하세요.

`[  ]` 파이프라인이 이용되지 않았을 때와 비교해서 2단계 파이프라인 적용시 이론적으로 최대 2배까지 속도 향상을 얻을 수 있다.

`[  ]` 인출 단계와 실행 단계에 할당된 시간은 다를 수 있다.

`[  ]` 인출 단계의 작업이 끝나면, 실행 단계의 작업 완료 여부와 무관하게 즉시 다음 명령어를 인출할 수 있다.

3번. '6개'의 명령어가 연속적으로 실행되었다고 한다. 파이프라인이 이용되지 않은 경우가 비교했을 때와 비교해서 2단계 파이프라인 적용시 속도 향상은 몇 배인가?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
1번. 빈칸에 알맞은 답을 채워주세요

`1) (명령어) 파이프라이닝` 이란 명령어를 실행하는데 사용되는 하드웨어를 여러 개의 독립적인 단계들로 분할하고, 그들로 하여금 동시에 서로 다른 명령어들을 처리하도록 함으로써 CPU의 성능을 높여지는 기술을 말한다.

2단계 명령어 파이프라인에서는 명령어를 실행하는 단계를 `2) 인출 단계`와 `3) 실행 단계`로 분리하여 구성할 수 있다.

2번. 다음 지문들의 참 거짓 여부를 표시하세요.

`[ O ]` 파이프라인이 이용되지 않았을 때와 비교해서 2단계 파이프라인 적용시 이론적으로 최대 2배까지 속도 향상을 얻을 수 있다.

`[ X ]` 인출 단계와 실행 단계에 할당된 시간은 다를 수 있다.

: clock 신호로 동기화되어 있으므로 다를 수 없다.

`[ X ]` 인출 단계의 작업이 끝나면, 실행 단계의 작업 완료 여부와 무관하게 즉시 다음 명령어를 인출할 수 있다.

: clock 신호에 맞춰서 다음 명령어를 인출하게 된다. '일반적으로' 실행 단계의 작업이 인출 단계보다 오래 걸리므로 clock 주기는 실행 단계에 맞게 설정되는데, 다시 말하면 실행 단계의 작업이 끝날 때까지 다음 명령어를 인출하지 못하고 대기해야만 한다.

3번. '6개'의 명령어가 연속적으로 실행되었다고 한다. 파이프라인이 이용되지 않은 경우가 비교했을 때와 비교해서 2단계 파이프라인 적용시 속도 향상은 몇 배인가? (소수점 1자리까지)

: 파이프라인이 적용되지 않았을 경우 -> 2 * 6 = 12주기

2단계 파이프라인이 적용되었을 경우 -> 7주기

즉, 12 / 7 = 1.7배

</details>
<br><br>

### 2.3 명령어 파이프라이닝 - 4단계　　　	`gaekim`

#### 4-단계 명령어 파이프라인

<img width="508" alt="스크린샷 2020-12-13 오후 7 34 36" src="https://user-images.githubusercontent.com/59970070/102009632-11467000-3d7c-11eb-854b-d698a89f0331.png">

**1번**

다음은 4-단계 명령어 파이프라인을 순서대로 설명한 내용이다. 보기에서 알맞은 답을 찾아 빈칸을 채우시오.  
  ```
  <보기>
  오퍼랜드 인출, 명령어 해독, 실행, 명령어 인출, 메모리 검사, CPU 점검
  ```

1. `________` : 명령어를 기억장치로부터 인출한다.
2. `________` : 해독기(decoder)를 이용하여 명령어를 해석한다.
3. `________` : 기억장치로부터 오퍼랜드를 인출한다.
4. `________` : 지정된 연산을 수행하고, 결과를 저장한다.
<br>

**2번**

2-단계 명령어 파이프라인에서 `인출 / 실행` 단계를 더 세분화함으로써 각 단계들의 처리 시간을 비슷해지도록 만든 것이다.
<br>

**3번**

4-단계 명령어 파이프라인에서 첫 번재 명령어의 실행이 완료되는 데 걸리는 시간과 두 번째 명령어의 실행에 걸리는 시간을 올바로 짝지은 것은 어느 것인가? [기본문제 2.10]

가. 1사이클-1사이클  나. 4사이클-1사이클  다. 1사이클-4사이클  라.4사이클-4사이클
<br>

**4번**

4-단계 파이프라인에서 10개의 명령어들을 실행하는 데는 모두 몇 사이클이 소요되는가? [기본문제 2.11]

Hint) `T = k + (N - 1)`   T: 전체 명령어 실행 시간, k: 파이프라인 단계의 수, N: 실행할 명령어들의 수

가. 10  나. 13  다. 14  라. 40
<br>

**5번**

각 파이프라인 단계는 한 클록 주기씩 걸린다고 가정할 때, 4-단계 파이프라인에서 97개의 명령어를 실행하여 얻을 수 있는 속도 향상(Sp)을 구하라. (주관식)

Hint)  `Sp = (k * N) / (k + (N - 1))`  Sp: 속도 향상, k: 파이프라인 단계의 수, N: 실행할 명령어들의 수

<br>
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>

### 2.3 명령어 파이프라이닝 - 슈퍼스칼라　　	`secho`


1번

`_____`는 CPU의 처리 속도를 **더욱** 높이기 위해 내부에 두개 혹은 그 이상의 `___ _____`들을 포함시킨 구조를 말한다.



2번.

슈퍼스칼라의 명령어 실행속도는 하나의 명령어 파이프라인에 비해 2배가 될 수 있는데, 한 명령어의 결과값으로 다음 명령어가 실행될 수 있는 `___ ___`이 존재하지 않아야한다는 조건이 있다.

---

교재 84p 파이프라인과 슈퍼스칼라 실행시간차이



![](https://images.velog.io/images/secho/post/281a7ed9-2070-4868-a8ee-4b35eebad4b3/image.png)

- 슈퍼스칼라의 실행속도는 하나의 명령어 파이프라인을 적용한 것보다  두 배가 될 수 있으며 파이프라인을 사용하지 않은 프로세서에 비해 최대 mk배 (주기 * 명령어 갯수)까지 얻을 수 있다. (4주기 * 4개명령어) = 16대
- 동시처리명령어 수를 높이면 파이프라인의 일부 단계가 유휴상태에 들어가기 때문에 속도향상은 이론보다 낮지만, 최근 고성능 프로세서들이 슈퍼스칼라 구조를 채택한다.



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

1번

`슈퍼스칼라`는 CPU의 처리 속도를 **더욱** 높이기 위해 내부에 두개 혹은 그 이상의 `명령어 파이프라인`들을 포함시킨 구조를 말한다.

- CPU 내에 명령어 파이프라인을 두어 동시에 그 수만큼 실행할 수 있도록 한 구조 = 슈퍼스칼라

2번.

슈퍼스칼라의 명령어 실행속도는 하나의 명령어 파이프라인에 비해 2배가 될 수 있는데, 한 명령어의 결과값으로 다음 명령어가 실행될 수 있는 `데이터 의존성`이 존재하지 않아야한다는 조건이 있다.

- 슈퍼스칼라는 동시에 처리할 명령어들이 서로 간에 영향을 받지 않고 독립적으로 실행될 수 있어야 한다.



</details>
<br><br>

### 2.3 명령어 파이프라이닝 - 듀얼/멀티코어　　　	`yeha`

요기엔 문제를 적어주세연-

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>


### 2.x 서브루틴 호출(Subroutine Call)　　　	`mihykim`

#### [문제1] <br>다음 중 인터럽트와 서브루틴의 👉공통점👈에 대해 바르게 설명한 사람을 골라주세요. (복수정답)

- `mihykim`: 인터럽트와 서브루틴 모두 **시스템 신호(Signal)에 의해 발생합니다.**

- `sancho`: 인터럽트와 서브루틴 모두 **점프하기 전에 복귀주소를 스택에 자동으로 저장합니다.**

- `jehong`: 인터럽트와 서브루틴 모두 **별도의 처리루틴으로 제어가 옮겨져서 프로그램을 수행합니다.**

- `kukim`: 인터럽트와 서브루틴 모두 **복귀 명령에 의해 원래의 위치로 복귀합니다.**

<br>

#### [문제2] <br><보기>에서 알맞은 말을 골라 인터럽트와 서브루틴 👉차이점👈 비교 표를 완성해주세요.

```
<보기>
- 코로나끝나서 마스크 벗고다녀도 될 경우
- 주변 장치가 CPU에게 긴급한 처리를 요구할 경우
- 유튜브에서 마음에 드는 플레이리스트를 찾았을 경우
- 한 블록으로 구성된 명령어 실행 중 또 다른 블록으로 구성된 명령어를 삽입하여 실행하고 싶은 경우
- 프로그램 외부(시스템)
- 프로그램 편성표
- 프로그램 내부(사용자)
- 신호(Signal)
- 핫초코(Hot Choco)
- 호출(Call)
- 입력 및 출력 파라미터가 없음
- 대부분 입력 및 출력 파라미터가 있음
```

|     구분     | 　　　　　　　인터럽트　　　　　　　 | 　　　　　　　서브루틴　　　　　　　 |
| :----------: | :----------------------------------: | :----------------------------------: |
|   **시점**   |               ` (a) `                |               ` (b) `                |
| **요청주체** |               ` (c) `                |               ` (d) `                |
| **요청방법** |               ` (e) `                |               ` (f) `                |
| **매개변수** |               ` (g) `                |               ` (h) `                |

<br>


#### [문제3] <br>다음 중 서브루틴 👉명령어 종류👈에 대해 바르게 설명한 사람을 골라주세요. (복수정답)

- `taelee`: **명령어 CALL** 은 현재 PC내용을 스택에 저장하고, PC에 호출될 서브루틴 시작 주소를 저장하여 원하는 서브루틴의 주소로 분기하는 명령어에요.

- `yeosong`: **명령어 RET**은 스택에 저장되어 있던 주소 값을 PC로 복원하여 CALL 명령어의 바로 다음주소로 되돌아가게 하는 명령어에요.

- `hylee`: **명령어 BR**은 프로그램의 실행순서를 변경하는 명령어에요. **BR** 이면 무조건 분기하는 거고, 조건코드가 0일때 분기하는 **BRZ**, 레지스터 내용이 같을 때 분기하는 **BRE**도 있어요.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

#### [문제1]
- 정답 : `sancho`, `jehong` `kukim`

  ```
  mihykim
  인터럽트와 서브루틴 모두 시스템 신호(Signal)에 의해 발생합니다.
  ▶ 인터럽트는 시스템 신호(Signal)에 의해 발생하지만, 서브루틴은 호출(Call)에 의해 발생합니다.
  ```
  
#### [문제2]
  
|     구분      |                     인터럽트                      |                           서브루틴                           |
| :-----------: | :-----------------------------------------------: | :----------------------------------------------------------: |
|  **공통점**   |                                                   |                                                              |
| 복귀주소 저장 |   점프하기 전에 복귀주소를 스택에 자동으로 저장   |                              〃                              |
|   수행방법    | 별도의 처리루틴으로 제어가 옮겨져서 프로그램 수행 |                              〃                              |
|   복귀방법    |        복귀 명령에 의해 원래의 위치로 복귀        |                              〃                              |
|  **차이점**   |                                                   |                                                              |
|     시점      |   주변 장치가 CPU에게 긴급한 처리를 요구할 경우   | 한 블록으로 구성된 명령어 실행 중<br>또 다른 블록으로 구성된 명령어를 삽입하여 실행하고 싶은 경우 |
|   요청주체    |               프로그램 외부(시스템)               |                    프로그램 내부(사용자)                     |
|   요청방법    |                   신호(Signal)                    |                          호출(Call)                          |
|   매개변수    |           입력 및 출력 파라미터가 없음            |             대부분 입력 및 출력 파라미터가 있음              |

#### [문제3]
- 정답 : `taelee`, `yeosong`

  ```
  hylee
  순서만 바꿔주는 분기 명령어는 서브루틴 명령어라고 하지 않는다. (별개로 간주)
  ```
