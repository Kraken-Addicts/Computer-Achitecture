## 🦄 인터럽트/서브루틴/파이프라이닝 (6 / 13회차)
<br>

### 2.3 명령어 파이프라이닝 - 2단계　　	`jakang`

1번. 빈칸에 알맞은 답을 채워주세요

`1) ________` 이란 명령어를 실행하는데 사용되는 하드웨어를 여러 개의 독립적인 단계들로 분할하고, 그들로 하여금 동시에 서로 다른 명령어들을 처리하도록 함으로써 CPU의 성능을 높여지는 기술을 말한다.

2단계 명령어 파이프라인에서는 명령어를 실행하는 단계를 `2) ________`와 `3) ________`로 분리하여 구성할 수 있다.

2번. 다음 지문들의 참 거짓 여부를 표시하세요.

`[  ]` 파이프라인이 이용되지 않았을 때와 비교해서 2단계 파이프라인 적용시 이론적으로 최대 2배까지 속도 향상을 얻을 수 있다.

`[  ]` 인출 단계와 실행 단계에 할당된 시간은 다를 수 있다.

`[  ]` 인출 단계의 작업이 끝나면, 실행 단계의 작업 완료 여부와 무관하게 즉시 다음 명령어를 인출할 수 있다.

3번. '6개'의 명령어가 연속적으로 실행되었다고 한다. 파이프라인이 이용되지 않은 경우가 비교했을 때와 비교해서 2단계 파이프라인 적용시 속도 향상은 몇 배인가?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
1번. 빈칸에 알맞은 답을 채워주세요

`1) (명령어) 파이프라이닝` 이란 명령어를 실행하는데 사용되는 하드웨어를 여러 개의 독립적인 단계들로 분할하고, 그들로 하여금 동시에 서로 다른 명령어들을 처리하도록 함으로써 CPU의 성능을 높여지는 기술을 말한다.

2단계 명령어 파이프라인에서는 명령어를 실행하는 단계를 `2) 인출 단계`와 `3) 실행 단계`로 분리하여 구성할 수 있다.

2번. 다음 지문들의 참 거짓 여부를 표시하세요.

`[ O ]` 파이프라인이 이용되지 않았을 때와 비교해서 2단계 파이프라인 적용시 이론적으로 최대 2배까지 속도 향상을 얻을 수 있다.

`[ X ]` 인출 단계와 실행 단계에 할당된 시간은 다를 수 있다.

: clock 신호로 동기화되어 있으므로 다를 수 없다.

`[ X ]` 인출 단계의 작업이 끝나면, 실행 단계의 작업 완료 여부와 무관하게 즉시 다음 명령어를 인출할 수 있다.

: clock 신호에 맞춰서 다음 명령어를 인출하게 된다. '일반적으로' 실행 단계의 작업이 인출 단계보다 오래 걸리므로 clock 주기는 실행 단계에 맞게 설정되는데, 다시 말하면 실행 단계의 작업이 끝날 때까지 다음 명령어를 인출하지 못하고 대기해야만 한다.

3번. '6개'의 명령어가 연속적으로 실행되었다고 한다. 파이프라인이 이용되지 않은 경우가 비교했을 때와 비교해서 2단계 파이프라인 적용시 속도 향상은 몇 배인가? (소수점 1자리까지)

: 파이프라인이 적용되지 않았을 경우 -> 2 * 6 = 12주기

2단계 파이프라인이 적용되었을 경우 -> 7주기

즉, 12 / 7 = 1.7배

</details>
<br><br>

### 2.3 명령어 파이프라이닝 - 4단계　　　	`gaekim`

#### 4-단계 명령어 파이프라인

<img width="508" alt="스크린샷 2020-12-13 오후 7 34 36" src="https://user-images.githubusercontent.com/59970070/102009632-11467000-3d7c-11eb-854b-d698a89f0331.png">

**1번**

다음은 4-단계 명령어 파이프라인을 순서대로 설명한 내용이다. 보기에서 알맞은 답을 찾아 빈칸을 채우시오. (영어로 답하면 안 됨)   
  ```
  <보기>
  오퍼랜드 인출, 명령어 해독, 실행, 명령어 인출, 메모리 검사, CPU 점검
  ```

1. `________` : 명령어를 기억장치로부터 인출한다.
2. `________` : 해독기(decoder)를 이용하여 명령어를 해석한다.
3. `________` : 기억장치로부터 오퍼랜드를 인출한다.
4. `________` : 지정된 연산을 수행하고, 결과를 저장한다.

**2번**

4-단계 명령어 파이프라인에서 첫 번재 명령어의 실행이 완료되는 데 걸리는 시간과 두 번째 명령어의 실행에 걸리는 시간을 올바로 짝지은 것은 어느 것인가? [기본문제 2.10]

&nbsp;&nbsp;&nbsp;&nbsp; 가. 1사이클-1사이클 &nbsp;&nbsp; 나. 4사이클-1사이클 &nbsp;&nbsp; 다. 1사이클-4사이클 &nbsp;&nbsp; 라.4사이클-4사이클
<br>

**3번**

4-단계 파이프라인에서 10개의 명령어들을 실행하는 데는 모두 몇 사이클이 소요되는가? [기본문제 2.11]

&nbsp;&nbsp;&nbsp; Hint) `T = k + (N - 1)`   T: 전체 명령어 실행 시간, k: 파이프라인 단계의 수, N: 실행할 명령어들의 수

&nbsp;&nbsp;&nbsp;&nbsp; 가. 10 &nbsp;&nbsp; 나. 13 &nbsp;&nbsp; 다. 14 &nbsp;&nbsp; 라. 40
<br>

**4번**

각 파이프라인 단계는 한 클록 주기씩 걸린다고 가정할 때, 4-단계 파이프라인에서 97개의 명령어를 실행하여 얻을 수 있는 속도 향상(Sp)을 구하라. (주관식)

&nbsp;&nbsp;&nbsp; Hint)  `Sp = (k * N) / (k + (N - 1))`  Sp: 속도 향상, k: 파이프라인 단계의 수, N: 실행할 명령어들의 수

<br>
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  

**1번**

다음은 4-단계 명령어 파이프라인을 순서대로 설명한 내용이다. 보기에서 알맞은 답을 찾아 빈칸을 채우시오. (영어로 답하면 안 됨)  
  ```
  <보기>
  오퍼랜드 인출, 명령어 해독, 실행, 명령어 인출, 메모리 검사, CPU 점검
  ```

1. `명령어 인출(IF)` : 명령어를 기억장치로부터 인출한다.
2. `명령어 해독(ID)` : 해독기(decoder)를 이용하여 명령어를 해석한다.
3. `오퍼랜드 인출(OF)` : 기억장치로부터 오퍼랜드를 인출한다.
4. `실행(EX)` : 지정된 연산을 수행하고, 결과를 저장한다.

**2번**

4-단계 명령어 파이프라인에서 첫 번재 명령어의 실행이 완료되는 데 걸리는 시간과 두 번째 명령어의 실행에 걸리는 시간을 올바로 짝지은 것은 어느 것인가? [기본문제 2.10]

&nbsp;&nbsp;&nbsp;&nbsp; 가. 1사이클-1사이클 &nbsp;&nbsp; 나. 4사이클-1사이클 &nbsp;&nbsp; 다. 1사이클-4사이클 &nbsp;&nbsp; 라.4사이클-4사이클
<br>

> 정답: 나. 4사이클-1사이클

> 첫 번째 명령어는 4단계(IF-ID-OF-EX)에 걸쳐 완료되고, 두 번째 명령어는 첫 번째 명령어의 2번째 사이클(ID)부터 인출되기 시작하므로, 첫 번째 명령어가 완료된 후 1사이클만에 두 번째 명령어가 실행된다.

**3번**

4-단계 파이프라인에서 10개의 명령어들을 실행하는 데는 모두 몇 사이클이 소요되는가? [기본문제 2.11]

&nbsp;&nbsp;&nbsp; Hint) `T = k + (N - 1)`   T: 전체 명령어 실행 시간, k: 파이프라인 단계의 수, N: 실행할 명령어들의 수

&nbsp;&nbsp;&nbsp;&nbsp; 가. 10 &nbsp;&nbsp; 나. 13 &nbsp;&nbsp; 다. 14 &nbsp;&nbsp; 라. 40
<br>

> 정답: 나. 13

> k가 4이고 n이 10이므로 T = 4 + (10 - 1) = 13

**4번**

각 파이프라인 단계는 한 클록 주기씩 걸린다고 가정할 때, 4-단계 파이프라인에서 97개의 명령어를 실행하여 얻을 수 있는 속도 향상(Sp)을 구하라. (주관식)

&nbsp;&nbsp;&nbsp; Hint)  `Sp = (k * N) / (k + (N - 1))`  Sp: 속도 향상, k: 파이프라인 단계의 수, N: 실행할 명령어들의 수

> 정답: 3.88 Sp

> Sp = (4*97) / (4 + (97-1)) = 3.88 Sp

</details>
<br><br>

### 2.3 명령어 파이프라이닝 - 슈퍼스칼라　　	`secho`


1번

`_____`는 CPU의 처리 속도를 **더욱** 높이기 위해 내부에 두개 혹은 그 이상의 `___ _____`들을 포함시킨 구조를 말한다.



2번.

슈퍼스칼라의 명령어 실행속도는 하나의 명령어 파이프라인에 비해 2배가 될 수 있는데, 한 명령어의 결과값으로 다음 명령어가 실행될 수 있는 `___ ___`이 존재하지 않아야한다는 조건이 있다.

---

교재 84p 파이프라인과 슈퍼스칼라 실행시간차이



![](https://images.velog.io/images/secho/post/281a7ed9-2070-4868-a8ee-4b35eebad4b3/image.png)

- 슈퍼스칼라의 실행속도는 하나의 명령어 파이프라인을 적용한 것보다  두 배가 될 수 있으며 파이프라인을 사용하지 않은 프로세서에 비해 최대 mk배 (주기 * 명령어 갯수)까지 얻을 수 있다. (4주기 * 4개명령어) = 16대
- 동시처리명령어 수를 높이면 파이프라인의 일부 단계가 유휴상태에 들어가기 때문에 속도향상은 이론보다 낮지만, 최근 고성능 프로세서들이 슈퍼스칼라 구조를 채택한다.



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

1번

`슈퍼스칼라`는 CPU의 처리 속도를 **더욱** 높이기 위해 내부에 두개 혹은 그 이상의 `명령어 파이프라인`들을 포함시킨 구조를 말한다.

- CPU 내에 명령어 파이프라인을 두어 동시에 그 수만큼 실행할 수 있도록 한 구조 = 슈퍼스칼라

2번.

슈퍼스칼라의 명령어 실행속도는 하나의 명령어 파이프라인에 비해 2배가 될 수 있는데, 한 명령어의 결과값으로 다음 명령어가 실행될 수 있는 `데이터 의존성`이 존재하지 않아야한다는 조건이 있다.

- 슈퍼스칼라는 동시에 처리할 명령어들이 서로 간에 영향을 받지 않고 독립적으로 실행될 수 있어야 한다.



</details>
<br><br>

### 2.3 명령어 파이프라이닝 - 듀얼/멀티코어　　　	`yeha`

**1. 보기에 있는 용어와 용어에 대한 설명을 알맞게 짝지어주세요.**


```
[보기]
 CPU 코어 (core) 
 멀티 코어 프로세서 (multi-core processor)
 멀티 태스킹 (multi-tasking)
 스레드 (thread)
```

- `(a)` : 여러 개의 CPU 코어들을 포함하고 있는 프로세서 칩
- `(b)` : 여러 CPU 코어들을 이용하여 독립적인 태스크 프로그램들을 동시에 처리하는 기술
- `(c)` : 독립적으로 실행될 수 있는 최소 크기의 프로그램 단위
- `(d)` : CPU 칩의 내부회로 중에서 명령어 실행에 반드시 필요한 핵심 부분들로 이루어진 하드웨어 모듈

**2. 다음 설명에 대해 맞으면 O, 틀리면 X 하세요.** 

(1) 코어의 개수가 많을수록 성능이 향상된다. (O/X)  
(2) 아래는 듀얼 코어 프로세서의 내부 구성도다. 해당 모델은 각 코어가 두 개의 레지스터 세트(RS)를  가지고 있어서 스레드를 두 개씩 동시에 처리할 수 있다. (O/X)  
<img width="387" alt="Screen Shot 2020-12-13 at 8 22 16 PM" src="https://user-images.githubusercontent.com/60090790/102010503-c7608880-3d81-11eb-8f39-d3c8ba76ef22.png">

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
**1.**
> (a) 멀티 코어 프로세서 (multi-core processor) : 여러 개의 CPU 코어들을 포함하고 있는 프로세서 칩  
(b) 멀티 태스킹 (multi-tasking) : 여러 CPU 코어들을 이용하여 독립적인 태스크 프로그램들을 동시에 처리하는 기술  
(c) 스레드 (thread)  : 독립적으로 실행될 수 있는 최소 크기의 프로그램 단위  
(d) CPU 코어(core) : CPU 칩의 내부회로 중에서 명령어 실행에 반드시 필요한 핵심 부분들로 이루어진 하드웨어 모듈

**2.** 
(1) 코어의 개수가 많을수록 성능이 향상된다. (X)  

> -> 반드시 그렇지는 않다.  
단일 코어 연산만을 지원하는 소프트웨어를 사용하거나 하나의 작업을 처리할 때는 코어 개수에 의한 성능 차이를 체감하지 못하거나 단일 코어가 빠를 수 있다. 멀티 프로세서를 지원하도록 프로그래밍 해야 한다. 오래 된 게임은 코어수보다 클럭수에 영향을 더 받을 수 있다.

(2) 아래는 듀얼 코어 프로세서의 내부 구성도다. 해당 모델은 각 코어가 두 개의 레지스터 세트(RS)를  가지고 있어서 스레드를 두 개씩 동시에 처리할 수 있다. (O)  

<img width="387" alt="Screen Shot 2020-12-13 at 8 22 16 PM" src="https://user-images.githubusercontent.com/60090790/102010503-c7608880-3d81-11eb-8f39-d3c8ba76ef22.png">

> -> 2코어 4스레드, 멀티 코어 멀티 스레딩 프로세서다.  
2코어의 2는 '물리적'인 CPU 코어의 개수 / 4스레드의 4는 '논리적' 코어의 개수, 동시에 실행 가능한 스레드의 개수다.  
위 모델에서 할당 가능한 스레드의 슬롯(동시에 실행 가능한 스레드 수)은 4개이나 생성할 수 있는 스레드 수는 메모리 등이 허용하는 한 얼마든지 많을 수 있다. 프로그램에서 얼마든지 스레드를 할당할 수 있고, 코어는 동시 실행 가능한 갯수만큼 스레드를 깨워서 실행한다.  
--  
2코어 4스레드는 상/하권으로 분권된 책이 2세트(=4권) 있는 것으로 비유해볼 수 있다. 도서관에 두고 사서가 관리할 때, 수많은 회원이 (대출/반납 규정을 지키며) 이 책을 읽을 수 있다. 다만, 한 번에 최대 4명까지만 읽을 수 있다. 2차선, 4차선 도로로 이해할수도 있다.    
--  
인텔의 마케팅 용어로 [하이퍼 스레딩(Hyper Threading)](https://www.intel.co.kr/content/www/kr/ko/gaming/resources/hyper-threading.html) 이 있다.  



</details>
<br><br>


### 2.x 서브루틴 호출(Subroutine Call)　　　	`mihykim`

#### [문제1] <br>다음 중 인터럽트와 서브루틴의 👉공통점👈에 대해 바르게 설명한 사람을 골라주세요. (복수정답)

- `mihykim`: 인터럽트와 서브루틴 모두 **시스템 신호(Signal)에 의해 발생합니다.**

- `sancho`: 인터럽트와 서브루틴 모두 **점프하기 전에 복귀주소를 스택에 자동으로 저장합니다.**

- `jehong`: 인터럽트와 서브루틴 모두 **별도의 처리루틴으로 제어가 옮겨져서 프로그램을 수행합니다.**

- `kukim`: 인터럽트와 서브루틴 모두 **복귀 명령에 의해 원래의 위치로 복귀합니다.**

<br>

#### [문제2] <br><보기>에서 알맞은 말을 골라 인터럽트와 서브루틴 👉차이점👈 비교 표를 완성해주세요.

```
<보기>
- 코로나끝나서 마스크 벗고다녀도 될 경우
- 주변 장치가 CPU에게 긴급한 처리를 요구할 경우
- 유튜브에서 마음에 드는 플레이리스트를 찾았을 경우
- 한 블록으로 구성된 명령어 실행 중 또 다른 블록으로 구성된 명령어를 삽입하여 실행하고 싶은 경우
- 프로그램 외부(시스템)
- 프로그램 편성표
- 프로그램 내부(사용자)
- 신호(Signal)
- 핫초코(Hot Choco)
- 호출(Call)
- 입력 및 출력 파라미터가 없음
- 대부분 입력 및 출력 파라미터가 있음
```

|     구분     | 　　　　　　　인터럽트　　　　　　　 | 　　　　　　　서브루틴　　　　　　　 |
| :----------: | :----------------------------------: | :----------------------------------: |
|   **시점**   |               ` (a) `                |               ` (b) `                |
| **요청주체** |               ` (c) `                |               ` (d) `                |
| **요청방법** |               ` (e) `                |               ` (f) `                |
| **매개변수** |               ` (g) `                |               ` (h) `                |

<br>


#### [문제3] <br>다음 중 서브루틴 👉명령어 종류👈에 대해 바르게 설명한 사람을 골라주세요. (복수정답)

- `taelee`: **명령어 CALL** 은 현재 PC내용을 스택에 저장하고, PC에 호출될 서브루틴 시작 주소를 저장하여 원하는 서브루틴의 주소로 분기하는 명령어에요.

- `yeosong`: **명령어 RET**은 스택에 저장되어 있던 주소 값을 PC로 복원하여 CALL 명령어의 바로 다음주소로 되돌아가게 하는 명령어에요.

- `hylee`: **명령어 BR**은 프로그램의 실행순서를 변경하는 명령어에요. **BR** 이면 무조건 분기하는 거고, 조건코드가 0일때 분기하는 **BRZ**, 레지스터 내용이 같을 때 분기하는 **BRE**도 있어요.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

#### [문제1]
- 정답 : `sancho`, `jehong` `kukim`

  ```
  mihykim
  인터럽트와 서브루틴 모두 시스템 신호(Signal)에 의해 발생합니다.
  ▶ 인터럽트는 시스템 신호(Signal)에 의해 발생하지만, 서브루틴은 호출(Call)에 의해 발생합니다.
  ```
  
#### [문제2]
  
|     구분      |                     인터럽트                      |                           서브루틴                           |
| :-----------: | :-----------------------------------------------: | :----------------------------------------------------------: |
|  **공통점**   |                                                   |                                                              |
| 복귀주소 저장 |   점프하기 전에 복귀주소를 스택에 자동으로 저장   |                              〃                              |
|   수행방법    | 별도의 처리루틴으로 제어가 옮겨져서 프로그램 수행 |                              〃                              |
|   복귀방법    |        복귀 명령에 의해 원래의 위치로 복귀        |                              〃                              |
|  **차이점**   |                                                   |                                                              |
|     시점      |   주변 장치가 CPU에게 긴급한 처리를 요구할 경우   | 한 블록으로 구성된 명령어 실행 중<br>또 다른 블록으로 구성된 명령어를 삽입하여 실행하고 싶은 경우 |
|   요청주체    |               프로그램 외부(시스템)               |                    프로그램 내부(사용자)                     |
|   요청방법    |                   신호(Signal)                    |                          호출(Call)                          |
|   매개변수    |           입력 및 출력 파라미터가 없음            |             대부분 입력 및 출력 파라미터가 있음              |

#### [문제3]
- 정답 : `taelee`, `yeosong`

  ```
  hylee
  순서만 바꿔주는 분기 명령어는 서브루틴 명령어라고 하지 않는다. (별개로 간주)
  ```
