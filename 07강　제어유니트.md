## 🦄 제어유니트 (7 / 13회차)
<br>

### 4.1 제어 유니트의 기능　　	`kukim`

#### 문제 1. Control Unit(제어 유닛ㅌ)의 주요 기능 두 가지는 무엇인가요? 보기에서 골라주세요

```c
[보기]
a) 명령어 코드 decode
b) 명령어 코드 encode
c) 명령어 실행에 필요한 제어 신호들의 발생
d) 어셈블리어 코드 생성
e) while(1) {printf("나는 제어 유니 ㅌㅌㅌㅌㅌ");}
```

#### 문제 2. Hardwired Contorl(하드와이어 제어)는 Microprogrammed Control(마이크로프로그램 제어)와는 다르게 하드웨어 변경 없이 컴퓨터 시스템 제어의 수정이 가능하다. (O / X)

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### 문제 1. Control Unit(제어 유닛ㅌ)의 주요 기능 두 가지는 무엇인가요? 보기에서 골라주세요

```c
[보기]
a) 명령어 코드 decode
b) 명령어 코드 encode
c) 명령어 실행에 필요한 제어 신호들의 발생
d) 어셈블리어 코드 생성
e) while(1) {printf("나는 제어 유니 ㅌㅌㅌㅌㅌ");}
```

- 정답 : a, c
    - 제어유닛의 기능
        1. 명령어 코드 해독
        2. 명령어 실행에 필요한 제어 신호 발생

#### 문제 2. Hardwired Contorl(하드와이어 제어)는 Microprogrammed Control(마이크로프로그램 제어)와는 다르게 하드웨어 변경 없이 컴퓨터 시스템 제어의 수정이 가능하다. (O / X)

- 정답 : X  (하드와이어로 동작하는 제어 유닛은 하드웨어를 변경 해야 제어 유닛을 수정할 수 있다.)

</details>
<br><br>

### 4.2 제어 유니트의 구조　　　	`mihykim`

<p><img src="https://user-images.githubusercontent.com/60066472/102344927-f3794500-3fdf-11eb-931b-87bff56eed6d.png" width="500"></p>

#### [문제 1]<br>위 그림을 참조하여 다음 빈 칸에 들어갈 제어 유니트의 주요구성요소를 알맞게 넣어주세요.
- `　　　　　　　　　　　　　`: <br>명령어 레지스터(IR)로부터 들어오는 명령어의 연산 코드를 해독하여 해당 연산을 수행하기 위한 루틴의 시작주소를 결정함
- `　　　　　　　　　　　　　`: <br>다음에 실행할 마이크로명령어의 주소(제어기억장치의 특정위치)를 저장하는 레지스터
- `　　　　　　　　　　　　　)`: <br>마이크로명령어들로 이루어진 마이크로프로그램을 저장하는 내부 기억장치
- `　　　　　　　　　　　　　`: <br>제어 기억장치로부터 읽혀진 마이크로 명령어를 일시적으로 저장하는 레지스터
- `　　　　　　　　　　　　　`: <br>마이크로프로그램에서 서브루틴이 호출되는 경우에, 현재의 CAR 내용을 일시적으로 저장하는 레지스터
- `　　　　　　　　　　　　　`: <br>마이크로명령어의 실행 순서를 결정하는 회로들의 집합

<br>

#### [문제 8]<br>용량이 128단어인 제어 기억장치의 처음 절반 부분에 실행 사이클 루틴들을 저장합니다. 각 루틴을 최대 8개의 마이크로명령어로 구성될 수 있도록 하려면, 사상 함수는 다음 중 어느 것과 같아야 할까요? (기본문제4.4)
  - 가. 0xxx000
  - 나. 0xxxx00
  - 다. 1xxxx00
  - 라. 1xxx00
  
```
사상(mapping)함수란?
- 명령어의 연산코드를 이용하여 해당 사이클 루틴의 시작 주소를 찾는 기법
- input: 연산코드
- output: 루틴의 시작주소
```

<br>

#### [문제 9]<br>제어유니트 명령어 실행 사이클 루틴들을 제어 기억장치의 절반 하반부에 저장하려고 합니다. 각 루틴은 최대 8개의 마이크로명령어들로 구성될 수 있도록 하며, 연산코드는 5비트입니다. (연습문제4.3)
- 명령어 해독을 위한 사상함수를 제시해주세요
- 제어기억장치의 0번지부터 상반부에는 인출 사이클을 비롯한 공통 루틴들을 저장한다면, 제어 기억장치의 전체 용량은 몇 단어(word)가 되어야 할까요?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### [문제 1]<br>위 그림을 참조하여 다음 빈 칸에 들어갈 제어 유니트의 주요구성요소를 알맞게 넣어주세요.
- `명령어 해독기(instruction decoder)`: <br>명령어 레지스터(IR)로부터 들어오는 명령어의 연산 코드를 해독하여 해당 연산을 수행하기 위한 루틴의 시작주소를 결정함
- `제어 주소 레지스터(control address register, CAR)`: <br>다음에 실행할 마이크로명령어의 주소(제어기억장치의 특정위치)를 저장하는 레지스터
- `제어 기억장치(control memory)`: <br>마이크로명령어들로 이루어진 마이크로프로그램을 저장하는 내부 기억장치
- `제어 버퍼 레지스터(control buffer register, CBR)`: <br>제어 기억장치로부터 읽혀진 마이크로 명령어를 일시적으로 저장하는 레지스터
- `서브루틴 레지스터(subroutine register, SBR)`: <br>마이크로프로그램에서 서브루틴이 호출되는 경우에, 현재의 CAR 내용을 일시적으로 저장하는 레지스터
- `순서제어 모듈(sequencing module)`: <br>마이크로명령어의 실행 순서를 결정하는 회로들의 집합

#### [문제 8]<br>용량이 128단어인 제어 기억장치의 처음 절반 부분에 실행 사이클 루틴들을 저장합니다. 각 루틴을 최대 8개의 마이크로명령어로 구성될 수 있도록 하려면, 사상 함수는 다음 중 어느 것과 같아야 할까요?
  - 답 : 가. 0xxx000
  ```
  ??????? : 총 128(=2^7)단어 이므로 7자리
  0?????? : 처음 절반이므로 최상위 비트 0
  0???000 : 각 루틴에 최대 8(=2^3)가지 이므로 000
  0xxx000 : 나머지는 연산코드 자리
  ```
  
#### [문제 9]<br>제어유니트 명령어 실행 사이클 루틴들을 제어 기억장치의 절반 하반부에 저장하려고 합니다. 각 루틴은 최대 8개의 마이크로명령어들로 구성될 수 있도록 하며, 연산코드는 5비트입니다.
- 명령어 해독을 위한 사상함수를 제시해주세요
  - 답 : 1xxxxx000
  ```
  1~        : 하반부이므로 최상위 비트 1
  1xxxxx~   : 연산코드 5비트
  1xxxxx000 : 각 루틴에 최대 8(=2^3)가지
  ```
  
- 제어기억장치의 0번지부터 상반부에는 인출 사이클을 비롯한 공통 루틴들을 저장한다면, 제어 기억장치의 전체 용량은 몇 단어(word)가 되어야 할까요?
  - 답: 512 워드
  ```
  1xxxxx000 => 9자리, 2^9 = 512
  => 공통 루틴 0~255
  => 실행사이클 루틴 256~511
  ```

</details>
<br><br>

### 4.3 마이크로명령어의 형식　　	`daelee`

![image](https://user-images.githubusercontent.com/37580034/102300675-b50c6780-3f98-11eb-8d45-f7248dff33e0.png)

##### [문제 1] 조건부 호출 마이크로-연산이 실행될 때 조건이 만족되었다면, 제어주소레지스터(CAR)에는 어떤 값이 적재될까요?

```
가. CAR <- CAR+1 
나. CAR <- ADF
다. CAR <- SBR
라. CAR <- SBR+1
```



##### [문제 2] 복귀(RET) 마이크로-연산이 실행되면, 제어주소레지스터(CAR)에는 어떤 값이 적재될까요?

```
가. CAR <- CAR+1 
나. CAR <- ADF
다. CAR <- SBR
라. CAR <- SBR+1
```




##### [문제 3] 설명이 맞으면 O, 틀리면 X 하세요. 

1. 하나의 동작만 지정하고 싶을 때에는 나머지 연산필드의 값을 이진수 `000`으로 지정한다. ( O / X )
2. 동시에 실행되는 마이크로연산들은 하나의 연산 필드에 위치시켜야 한다. ( O / X )
3. 분기 필드의 값이 JMP/CALL라면 앞의 조건 필드가 `00` 이더라도 조건을 만족하는 지 확인한 후 분기한다. ( O / X )
4. 호출되는 마지막 마이크로명령어의 분기 필드에는 반드시 return을 뜻하는 `10` 이 들어가야한다. ( O / X )



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
![image](https://user-images.githubusercontent.com/37580034/102300675-b50c6780-3f98-11eb-8d45-f7248dff33e0.png)

##### [문제 1] 조건부 호출 마이크로-연산이 실행될 때 조건이 만족되었다면, 제어주소레지스터(CAR)에는 어떤 값이 적재될까요?

```
가. CAR <- CAR+1 
나. CAR <- ADF
다. CAR <- SBR
라. CAR <- SBR+1
```

> **정답 : 나**
>
> 조건을 만족한 경우 호출 연산이 실행되고, 이 경우 마지막 주소필드(ADF)의 값이 분기될 목적지 마이크로명령어 주소가 된다. 즉, ADF의 값이 CAR로 적재된다.



##### [문제 2] 복귀(RET) 마이크로-연산이 실행되면, 제어주소레지스터(CAR)에는 어떤 값이 적재될까요?

```
가. CAR <- CAR+1 
나. CAR <- ADF
다. CAR <- SBR
라. CAR <- SBR+1
```

> **정답 : 다**
>
> 서브루틴 레지스터(SBR)은 마이크로프로그램에서 서브 루틴이 호출되는 경우에 현재의 CAR 내용을 일시적으로 저장하는 레지스터. SBR에 저장되어 있던 주소가 CAR에 다시 적재됨으로서 호출되기 전의 프로그램 실행 순서로 되돌아가게 된다. 



##### [문제 3] 설명이 맞으면 O, 틀리면 X 하세요. 

1. 하나의 동작만 지정하고 싶을 때에는 나머지 연산필드의 값을 이진수 `000`으로 지정한다. ( O / X )
2. 동시에 실행되는 마이크로연산들은 하나의 연산 필드에 위치시켜야 한다. ( O / X )
3. 분기 필드의 값이 JMP/CALL라면 앞의 조건 필드가 `00` 이더라도 조건을 만족하는 지 확인한 후 분기한다. ( O / X )
4. 호출되는 마지막 마이크로명령어의 분기 필드에는 반드시 return을 뜻하는 `10` 이 들어가야한다. ( O / X )

> **정답 : O, X, X, O**
>
> 1. O, 000은 None을 의미한다.
> 2. X, 두 개의 마이크로연산을 동시에 실행시키고 싶다면 두 개의 연산필드를 사용해야 한다.
> 3. X, JMP와 CALL은 앞의 조건 필드가 `00` 이라면 무조건 점프/호출이 수행된다.
> 4. O

</details>
<br><br>

### 4.4 마이크로프로그래밍　　　　	`sancho`

#### 1. 인출 사이클 루틴이 실행될 때 다음 위치에 들어갈 마이크로 명령어를 적어주세요.
![스크린샷 2020-12-16 오후 12 25 34](https://user-images.githubusercontent.com/58046372/102301695-aaeb6880-3f9a-11eb-8f0d-18cdfe582ada.png)
<br><br>

#### 2. 간접 사이클 루틴을 사용하려 할 때 I비트에 세트된 값은 무엇일까요?
-> 
<br><br>

#### 3. 간접 사이클 루틴이 실행될 때 다음 위치에 들어갈 마이크로 명령어를 적어주세요.
![스크린샷 2020-12-16 오후 12 52 45](https://user-images.githubusercontent.com/58046372/102303077-bf7d3000-3f9d-11eb-8da4-d3cd65479fcf.png)
<br><br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  

#### 1. 인출 사이클 루틴이 실행될 때 다음 위치에 들어갈 마이크로 명령어를 적어주세요.
![스크린샷 2020-12-16 오후 12 25 34](https://user-images.githubusercontent.com/58046372/102301695-aaeb6880-3f9a-11eb-8f0d-18cdfe582ada.png)
1. PCTAR: 인출 사이클의 첫번째로 PC의 내용을 MAR에 보내는 과정의 마이크로 명령어는 PCTAR이며 다음 마이크로 명령어가 실행됩니다.<br>
2. READ, INCPC: 두번째에서는 첫번째에서 읽혀진 명령어가 MBR로 적재되고 PC의 내용에 1을 증가시키는 과정이 일어납니다. 이를 마이크로 명령어로 바꾸면 READ, INCPC가 됩니다. <br>
3. BRTIR, 세번째에서 MBR에 저장된 명령어 코드가 IR로 이동하게 되는데 마이크로 명령어로 바꾸면 BRTIR입니다.
<br><br>

#### 2. 간접 사이클 루틴을 사용하려 할 때 I비트에 세트된 값은 무엇일까요?
-> 간접 주소지정 방식을 사용하기 위해선 I비트가 1로 세트되어야 합니다.
<br><br>

#### 3. 간접 사이클 루틴이 실행될 때 다음 위치에 들어갈 마이크로 명령어를 적어주세요.
![스크린샷 2020-12-16 오후 12 52 45](https://user-images.githubusercontent.com/58046372/102303077-bf7d3000-3f9d-11eb-8da4-d3cd65479fcf.png)
1. IRTAR, 2. READ, 3. BRTIR<br>
<br>
-> 간접 사이클은 간접 주소지정 방식을 사용하고 있는 데이터의 실제 위치를 불러오기 위한 과정이고 이를 순서대로 마이크로 명령어로 바꾸면 IRTAR, READ, BRTIR이 됩니다.<br><br>


</details>
<br><br>


### 4.5 마이크로프로그램의 순서제어　　　　	`yeosong`

요기엔 문제를 적어주세연-

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>
