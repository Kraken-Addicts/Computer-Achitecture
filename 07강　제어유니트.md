## 🦄 제어유니트 (7 / 13회차)
<br>

### 4.1 제어 유니트의 기능　　	`kukim`

요기엔 문제를 적어주세연-

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### 문제 1. Control Unit(제어 유닛ㅌ)의 주요 기능 두 가지는 무엇인가요? 보기에서 골라주세요

```c
[보기]
a) 명령어 코드 decode
b) 명령어 코드 encode
c) 명령어 실행에 필요한 제어 신호들의 발생
d) 어셈블리어 코드 생성
e) while(1) {printf("나는 제어 유니 ㅌㅌㅌㅌㅌ");}
```

- 정답 : a, c
    - 제어유닛의 기능
        1. 명령어 코드 해독
        2. 명령어 실행에 필요한 제어 신호 발생

#### 문제 2. Hardwired Contorl(하드와이어 제어)는 Microprogrammed Control(마이크로프로그램 제어)와는 다르게 하드웨어 변경 없이 컴퓨터 시스템 제어의 수정이 가능하다. (O / X)

- 정답 : X  (하드와이어로 동작하는 제어 유닛은 하드웨어를 변경 해야 제어 유닛을 수정할 수 있다.)

</details>
<br><br>

### 4.2 제어 유니트의 구조　　　	`mihykim`

요기엔 문제를 적어주세연-

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>

### 4.3 마이크로명령어의 형식　　	`daelee`

![image](https://user-images.githubusercontent.com/37580034/102300675-b50c6780-3f98-11eb-8d45-f7248dff33e0.png)

##### [문제 1] 조건부 호출 마이크로-연산이 실행될 때 조건이 만족되었다면, 제어주소레지스터(CAR)에는 어떤 값이 적재될까요?

```
가. CAR <- CAR+1 
나. CAR <- ADF
다. CAR <- SBR
라. CAR <- SBR+1
```



##### [문제 2] 복귀(RET) 마이크로-연산이 실행되면, 제어주소레지스터(CAR)에는 어떤 값이 적재될까요?

```
가. CAR <- CAR+1 
나. CAR <- ADF
다. CAR <- SBR
라. CAR <- SBR+1
```




##### [문제 3] 설명이 맞으면 O, 틀리면 X 하세요. 

1. 하나의 동작만 지정하고 싶을 때에는 나머지 연산필드의 값을 이진수 `000`으로 지정한다. ( O / X )
2. 동시에 실행되는 마이크로연산들은 하나의 연산 필드에 위치시켜야 한다. ( O / X )
3. 분기 필드의 값이 JMP/CALL라면 앞의 조건 필드가 `00` 이더라도 조건을 만족하는 지 확인한 후 분기한다. ( O / X )
4. 호출되는 마지막 마이크로명령어의 분기 필드에는 반드시 return을 뜻하는 `10` 이 들어가야한다. ( O / X )



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
![image](https://user-images.githubusercontent.com/37580034/102300675-b50c6780-3f98-11eb-8d45-f7248dff33e0.png)

##### [문제 1] 조건부 호출 마이크로-연산이 실행될 때 조건이 만족되었다면, 제어주소레지스터(CAR)에는 어떤 값이 적재될까요?

```
가. CAR <- CAR+1 
나. CAR <- ADF
다. CAR <- SBR
라. CAR <- SBR+1
```

> **정답 : 나**
>
> 조건을 만족한 경우 호출 연산이 실행되고, 이 경우 마지막 주소필드(ADF)의 값이 분기될 목적지 마이크로명령어 주소가 된다. 즉, ADF의 값이 CAR로 적재된다.



##### [문제 2] 복귀(RET) 마이크로-연산이 실행되면, 제어주소레지스터(CAR)에는 어떤 값이 적재될까요?

```
가. CAR <- CAR+1 
나. CAR <- ADF
다. CAR <- SBR
라. CAR <- SBR+1
```

> **정답 : 다**
>
> 서브루틴 레지스터(SBR)은 마이크로프로그램에서 서브 루틴이 호출되는 경우에 현재의 CAR 내용을 일시적으로 저장하는 레지스터. SBR에 저장되어 있던 주소가 CAR에 다시 적재됨으로서 호출되기 전의 프로그램 실행 순서로 되돌아가게 된다. 



##### [문제 3] 설명이 맞으면 O, 틀리면 X 하세요. 

1. 하나의 동작만 지정하고 싶을 때에는 나머지 연산필드의 값을 이진수 `000`으로 지정한다. ( O / X )
2. 동시에 실행되는 마이크로연산들은 하나의 연산 필드에 위치시켜야 한다. ( O / X )
3. 분기 필드의 값이 JMP/CALL라면 앞의 조건 필드가 `00` 이더라도 조건을 만족하는 지 확인한 후 분기한다. ( O / X )
4. 호출되는 마지막 마이크로명령어의 분기 필드에는 반드시 return을 뜻하는 `10` 이 들어가야한다. ( O / X )

> **정답 : O, X, X, O**
>
> 1. O, 000은 None을 의미한다.
> 2. X, 두 개의 마이크로연산을 동시에 실행시키고 싶다면 두 개의 연산필드를 사용해야 한다.
> 3. X, JMP와 CALL은 앞의 조건 필드가 `00` 이라면 무조건 점프/호출이 수행된다.
> 4. O

</details>
<br><br>

### 4.4 마이크로프로그래밍　　　　	`sancho`

#### 1. 인출 사이클 루틴이 실행될 때 다음 위치에 들어갈 마이크로 명령어를 적어주세요.
![스크린샷 2020-12-16 오후 12 25 34](https://user-images.githubusercontent.com/58046372/102301695-aaeb6880-3f9a-11eb-8f0d-18cdfe582ada.png)
<br><br>

#### 2. 간접 사이클 루틴을 사용하려 할 때 I비트에 세트된 값은 무엇일까요?
-> 
<br><br>

#### 3. 간접 사이클 루틴이 실행될 때 다음 위치에 들어갈 마이크로 명령어를 적어주세요.
![스크린샷 2020-12-16 오후 12 52 45](https://user-images.githubusercontent.com/58046372/102303077-bf7d3000-3f9d-11eb-8da4-d3cd65479fcf.png)
<br><br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  

#### 1. 인출 사이클 루틴이 실행될 때 다음 위치에 들어갈 마이크로 명령어를 적어주세요.
![스크린샷 2020-12-16 오후 12 25 34](https://user-images.githubusercontent.com/58046372/102301695-aaeb6880-3f9a-11eb-8f0d-18cdfe582ada.png)
1. PCTAR: 인출 사이클의 첫번째로 PC의 내용을 MAR에 보내는 과정의 마이크로 명령어는 PCTAR이며 다음 마이크로 명령어가 실행됩니다.<br>
2. READ, INCPC: 두번째에서는 첫번째에서 읽혀진 명령어가 MBR로 적재되고 PC의 내용에 1을 증가시키는 과정이 일어납니다. 이를 마이크로 명령어로 바꾸면 READ, INCPC가 됩니다. <br>
3. BRTIR, 세번째에서 MBR에 저장된 명령어 코드가 IR로 이동하게 되는데 마이크로 명령어로 바꾸면 BRTIR입니다.
<br><br>

#### 2. 간접 사이클 루틴을 사용하려 할 때 I비트에 세트된 값은 무엇일까요?
-> 간접 주소지정 방식을 사용하기 위해선 I비트가 1로 세트되어야 합니다.
<br><br>

#### 3. 간접 사이클 루틴이 실행될 때 다음 위치에 들어갈 마이크로 명령어를 적어주세요.
![스크린샷 2020-12-16 오후 12 52 45](https://user-images.githubusercontent.com/58046372/102303077-bf7d3000-3f9d-11eb-8da4-d3cd65479fcf.png)
1. IRTAR, 2. READ, 3. BRTIR<br>
<br>
-> 간접 사이클은 간접 주소지정 방식을 사용하고 있는 데이터의 실제 위치를 불러오기 위한 과정이고 이를 순서대로 마이크로 명령어로 바꾸면 IRTAR, READ, BRTIR이 됩니다.<br><br>


</details>
<br><br>


### 4.5 마이크로프로그램의 순서제어　　　　	`yeosong`

요기엔 문제를 적어주세연-

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>
