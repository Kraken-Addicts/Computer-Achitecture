## 🦄 ALU: Logic Operations (2 / 13회차)
<br>

### 3.1 ALU의 구성 요소　　	`mihykim`
#### [문제1]<br>성실한 예비개발자 'daelee'는 꿈에 그리던 기업 Nakalcoub에 면접을 보게되었습니다. 'daelee'를 도와 면접 질문의 답을 완성해주세요!
- __면접관__ : "흠흠.. 머리숱이 아주 많은 지원자시군요...(부럽) 그럼 ALU가 무엇인지 간단하게 설명해주시겠어요?"
- __DAELEE__ : "아 넵! ALU는... `　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　 　　　`"
<br>

#### [문제2]<br>'mihykim'은 ALU 구성요소 학습을 마치고 그 내용을 블럭으로 가지런히 정리해두었습니다. 그런데 월요일 아침, 주말에 다녀간 조카가 블럭을 다 빼놓은 것을 발견했습니다. 당황한 'mihykim'을 도와 블럭순서를 바르게 맞춰주세요.
```
<블럭>
[ 보수기(complementer) ]
[ 시프트 레지스터 ]
[ 논리연산장치(LU) ]
[ 산술연산장치(AU) ]
[ 상태 레지스터 ]
```
- 산술 연산(+, -, X, %)을 수행하는 장치 : `[　　　　]`
- 논리 연산(&, |, ^, !)을 수행하는 장치 : `[　　　　]`
- 비트들을 좌측 혹은 우측으로 이동시켜주는 레지스터 :  `[　　　　]`
- 데이터에 2의 보수를 취해주는 요소 : `[　　　　]`
- 연산 결과의 상태를 나타내는 플래그들을 저장하는 레지스터 :  `[　　　　]`
<br>

#### [문제3]<br>컴퓨터구조 스터디원들은 ALU 상태레지스터 내 '상태 플래그'에 대해 서로 공유하기로 하였습니다. 다음 내용 중 사실과는 다른 내용을 이야기하는 사람은 누구일까요? (복수 정답)
```
'gaekim' : 프로세서 설계에 따라 상태 플래그의 구성과 그 기능이 약간씩 다를 수 있대요.

'sancho' : 맞아요. 일부 아키텍처에서는 상태 레지스터가 아예 없기도 한가봐요. 그럼 주로 쓰이는 플래그들을 말해볼까요?

'hylee' : (스읍-) 음... 일단 제로 플래그(Z)가 있겠어요. 연산의 결과가 0일 경우에 참이 되지요.

'kycho' : 아, 제로플래그는 리버스 엔지니어링에서 구조를 추적하는데 매우 중요한 플래그라고 하네요.

'jakang' : 비슷하게 연산의 결과가 음수일 때 참이되는 네거티브 플래그(N)도 있어요.

'yeosong' : unsigned 숫자의 연산결과가 비트 범위를 넘어설 때 필요한 플래그도 있어요.

'jehong' : 캐리 플래그(C) 말씀하시는거죠? 처음엔 오버플로우 플래그(O)랑 헷갈렸는데 알아보니 아예 똑같은 것 같더라구요.

'taelee' : 와 다들 잘 알고 계시네요. 인터럽트 요구를 받아들일지 말지 결정하는 인터럽트 플래그(I)도 있습니다!
```
<br>

#### 먼저 푸신 분을 위한 🍪
- 4비트 ALU 중 하나인 인텔 74181은 약 70개의 논리게이트를 사용했고 곱셈과 나눗셈은 할 수 없었다.
- 8비트 ALU를 완전히 구축하려면 수백개의 논리게이트가 필요하다.
- 수 백개의 논리게이트를 다 표현하려면 너무 복잡하니까 아래와 같은 다이어그램으로 ALU를 추상화해서 표현한다.
![image](https://user-images.githubusercontent.com/60066472/100407924-12ee1380-30ad-11eb-8b19-a272f00714fd.png)
<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### [문제1]<br>성실한 예비개발자 'daelee'는 꿈에 그리던 기업 Nakalcoub에 면접을 보게되었습니다. 'daelee'를 도와 면접 질문의 답을 완성해주세요!
- __면접관__ : "흠흠.. 머리숱이 아주 많은 지원자시군요...(부럽) 그럼 ALU가 무엇인지 간단하게 설명해주시겠어요?"
- __DAELEE__ : "아 넵! ALU는 `CPU의 주요 구성요소 중 하나로, Arithmetic Logic Unit이라는 이름 그대로 산술논리연산장치를 말합니다.
덧셈뺄셈과 같은 산술연산과 AND, OR와 같은 논리연산을 수행하는 핵심적인 회로입니다.`"
<br>

#### [문제2]<br>'mihykim'은 ALU 구성요소 학습을 마치고 그 내용을 블럭으로 가지런히 정리해두었습니다. 그런데 월요일 아침, 주말에 다녀간 조카가 블럭을 다 빼놓은 것을 발견했습니다. 당황한 'mihykim'을 도와 블럭순서를 바르게 맞춰주세요.
- 산술 연산(+, -, X, %)을 수행하는 장치 : `[ 산술연산장치(AU) ]`
- 논리 연산(&, |, ^, !)을 수행하는 장치 : `[ 논리연산장치(LU) ]`
- 비트들을 좌측 혹은 우측으로 이동시켜주는 레지스터 :  `[ 시프트 레지스터 ]`
- 데이터에 2의 보수를 취해주는 요소 : `[ 보수기(complementer) ]`
- 연산 결과의 상태를 나타내는 플래그들을 저장하는 레지스터 :  `[ 상태 레지스터 ]`
<br>

#### [문제3]<br>컴퓨터구조 스터디원들은 ALU 상태레지스터 내 '상태 플래그'에 대해 서로 공유하기로 하였습니다. 다음 내용 중 사실과는 다른 내용을 이야기하는 사람은 누구일까요? (복수 정답)
```
'jehong'
캐리 플래그(C) 말씀하시는거죠? 처음엔 오버플로우 플래그(O)랑 헷갈렸는데 알아보니 확실히 다른 것이더라구요. 
캐리 플래그는 최상단 비트에서 자리올림 발생 시 Set되고
오버플로우 플래그는 최대 표현 범위를 넘어섰거나, 같은 부호를 더했는데 다른 부호가 나와버릴 때 Set 된답니다.
예를 들어 1000 + 1000 => 10000 에서는 캐리 플래그가,
0111 + 0001 => 1000 에서는 오버플로우가 Set됩니다. (7 + 1 => -8)
```
```
'taelee'
와 다들 잘 알고 계시네요!
지금까지는 상태플래그를 이야기했는데 상태레지스터에는 CPU를 제어하기위해 사용되는 제어플래그(Control flag)도 있답니다. 
그 예로 인터럽트 요구를 받아들일지 말지 결정하는 인터럽트 플래그(I)가 있습니다!
```
<br>

</details>
<br><br>

### 3.2 정수의 표현　　　	`daelee`

#### 부호없는(Unsigned) 정수 표현(책 요약)

- n비트 조합에서 의미있는 조합의 개수 : 2^n 

  - 3bit 라면 000, 001, 010, 011, 100, 101, 110, 111 총 8개의 조합이 가능함.

- n비트에서 표현 가능한 10진수 범위 : 0 ~ 2^n - 1 

- n비트로 표현된 2진수를 10진수로 변환하는 일반식

  ![image-20201129001019628](https://user-images.githubusercontent.com/37580034/100521739-b8f26880-31e8-11eb-8f1a-a16575e65987.png)


- Bit Extension 방법 : 상위(좌측) 남는 비트부터 0추가

  - 8비트를 16비트에 저장헤야할 때 
  - 57(10) = 00111001(8), 0000000000111001(16)
  
#### 부호있는(Signed) 정수 표현(문제)

1. 아래와 같이 부호화-크기(signed-magnitude representation)로 표현된 수들을 10진수로 변환하세요.

   - 0 0110101 = 
   - 1 1010101 = 
   - 1 000 =


2. **부호화-크기** 표현의 가장 큰 단점 두 가지를 설명해주세요. 



3. 1의 보수 표현(1’s complement representation)의 음수화(negation) 방법을 설명해주세요.



4. 2의 보수 표현(2’s complement representation)의 음수화(negation) 방법을 설명해주세요.



5. 2의 보수로 표현된 `10111010`을 10진수로 변환하세요.



   

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
1. 아래와 같이 부호화-크기(signed-magnitude representation)로 표현된 수들을 10진수로 변환하세요.

   - 0 0110101 = 
   - 1 1010101 = 
   - 1 000 =
 

   > 정답 : 
   >
   > - 0 0110101 = 1 * (1x2^5 + 1x2^4 + 1x2^2 + 1x2^0) = (32 + 16 + 4 + 1) = 53  
   > - 1 1010101 = -53
   > - 1 000 = 0

2. **부호화-크기** 표현의 가장 큰 단점 두 가지를 설명해주세요. 

   > 정답 : 
   >
   > 1. n비트 조합에서 의미있는 조합의 개수 : 2^n 가 아니라 2^n - 1 이다. 부호화-크기 표현에서는 1000(2)과 0000(2) 둘 다 0을 표현하므로 **하나의 조합을 낭비하게 된다.**
   > 2. 계산을 수행할 때 **부호비트와 크기 부분을 별도로 처리**해야한다. 크기 부분만 따로 계산한 뒤 크기 부분의 절댓값이 더 큰 수의 부호를 결과값의 부호로 세트해야함. 귀찮음.

3. 1의 보수 표현(1’s complement representation)의 음수화(negation) 방법을 설명해주세요.

   > 정답 : **모든 비트들을 반전한다.** (0 -> 1, 1 -> 0)
   >
   > - 1의 보수 표현에서 **Bit Extension**은 Sign Bit 다음에 Sign Bit와 같은 수를 추가하는 방식으로 이루어진다.
   > - 그러나 여전히 0에 대한 표현이 두 가지이므로 조합의 낭비가 발생한다. 그래서 일반적으로 컴퓨터는 2의 보수 표현법을 더 많이(아니 거의 100%) 사용한다.

4. 2의 보수 표현(2’s complement representation)의 음수화(negation) 방법을 설명해주세요.

   > 정답 : 모든 비트들을 반전하고, **결과값에 1을 더한다.**
   >
   > 1을 더함으로서 조합의 개수를 낭비하지 않게 되었다! 2의 보수 표현에서는 음수0이 사라진 대신, 음수0은 절대값이 가장 큰 음수와 매핑된다. 예를 들어, 100(2)은 부호화-크기 표현에서 음수 0이었지만, 2의보수 표현에서는 -4다.

5. 2의 보수로 표현된 `10111010`을 10진수로 변환하세요.

   > 정답 : **-70**
   >
   > 방법1. 책 145p 예제(3-4) 일반식 참고
   >
   > -  -128 + (1x2^5 + 1x2^4 + 1x2^3 + 1x2^1) = -128 + (32 + 16 + 8 + 2) = -70
   > <br>
   >
   > 방법2. 책 146p 예제(3-6) 참고
   >
   > 1. 10111010 - 1 한 뒤 => 10111001
   > 2.  0은 1로, 1은 0으로 바꿔주기 =>   01000110
   > 3. 10진수로 변환하고 - 부호 붙이기 => -70

   

</details>
<br><br>

### 3.3 논리 연산　　	`sancho`

#### [문제1]<br>선택적-세트 연산을 적용할 A레지스터가 01001100일 때 상위 4비트를 바꾸기 위한 B레지스터의 값을 적어주세요. 
#### [문제2]<br>


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>

### 3.4 시프트 연산　　　	`yeosong`

요기엔 문제를 적어주세연-

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>
