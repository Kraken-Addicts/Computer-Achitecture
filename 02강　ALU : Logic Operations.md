## 🦄 ALU: Logic Operations (2 / 13회차)
<br>

### 3.1 ALU의 구성 요소　　	`mihykim`
#### [문제1]<br>성실한 예비개발자 'daelee'는 꿈에 그리던 기업 Nakalcoub에 면접을 보게되었습니다. 'daelee'를 도와 면접 질문의 답을 완성해주세요!
- __면접관__ : "흠흠.. 머리숱이 아주 많은 지원자시군요...(부럽) 그럼 ALU가 무엇인지 간단하게 설명해주시겠어요?"
- __DAELEE__ : "아 넵! ALU는... `　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　 　　　`"
<br>

#### [문제2]<br>'mihykim'은 ALU 구성요소 학습을 마치고 그 내용을 블럭으로 가지런히 정리해두었습니다. 그런데 월요일 아침, 주말에 다녀간 조카가 블럭을 다 빼놓은 것을 발견했습니다. 당황한 'mihykim'을 도와 블럭순서를 바르게 맞춰주세요.
```
<블럭>
[ 보수기(complementer) ]
[ 시프트 레지스터 ]
[ 논리연산장치(LU) ]
[ 산술연산장치(AU) ]
[ 상태 레지스터 ]
```
- 산술 연산(+, -, X, %)을 수행하는 장치 : `[　　　　]`
- 논리 연산(&, |, ^, !)을 수행하는 장치 : `[　　　　]`
- 비트들을 좌측 혹은 우측으로 이동시켜주는 레지스터 :  `[　　　　]`
- 데이터에 2의 보수를 취해주는 요소 : `[　　　　]`
- 연산 결과의 상태를 나타내는 플래그들을 저장하는 레지스터 :  `[　　　　]`
<br>

#### [문제3]<br>컴퓨터구조 스터디원들은 ALU 상태레지스터 내 '상태 플래그'에 대해 서로 공유하기로 하였습니다. 다음 내용 중 사실과는 다른 내용을 이야기하는 사람은 누구일까요? (복수 정답)
```
'gaekim' : 프로세서 설계에 따라 상태 플래그의 구성과 그 기능이 약간씩 다를 수 있대요.

'sancho' : 맞아요. 일부 아키텍처에서는 상태 레지스터가 아예 없기도 한가봐요. 그럼 주로 쓰이는 플래그들을 말해볼까요?

'hylee' : (스읍-) 음... 일단 제로 플래그(Z)가 있겠어요. 연산의 결과가 0일 경우에 참이 되지요.

'kycho' : 아, 제로플래그는 리버스 엔지니어링에서 구조를 추적하는데 매우 중요한 플래그라고 하네요.

'jakang' : 비슷하게 연산의 결과가 음수일 때 참이되는 네거티브 플래그(N)도 있어요.

'yeosong' : unsigned 숫자의 연산결과가 비트 범위를 넘어설 때 필요한 플래그도 있어요.

'jehong' : 캐리 플래그(C) 말씀하시는거죠? 처음엔 오버플로우 플래그(O)랑 헷갈렸는데 알아보니 아예 똑같은 것 같더라구요.

'taelee' : 와 다들 잘 알고 계시네요. 인터럽트 요구를 받아들일지 말지 결정하는 인터럽트 플래그(I)도 있습니다!
```
<br>

#### 먼저 푸신 분을 위한 🍪
- 4비트 ALU 중 하나인 인텔 74181은 약 70개의 논리게이트를 사용했고 곱셈과 나눗셈은 할 수 없었다.
- 8비트 ALU를 완전히 구축하려면 수백개의 논리게이트가 필요하다.
- 수 백개의 논리게이트를 다 표현하려면 너무 복잡하니까 아래와 같은 다이어그램으로 ALU를 추상화해서 표현한다.
![image](https://user-images.githubusercontent.com/60066472/100407924-12ee1380-30ad-11eb-8b19-a272f00714fd.png)
<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### [문제1]<br>성실한 예비개발자 'daelee'는 꿈에 그리던 기업 Nakalcoub에 면접을 보게되었습니다. 'daelee'를 도와 면접 질문의 답을 완성해주세요!
- __면접관__ : "흠흠.. 머리숱이 아주 많은 지원자시군요...(부럽) 그럼 ALU가 무엇인지 간단하게 설명해주시겠어요?"
- __DAELEE__ : "아 넵! ALU는 `CPU의 주요 구성요소 중 하나로, Arithmetic Logic Unit이라는 이름 그대로 산술논리연산장치를 말합니다.
덧셈뺄셈과 같은 산술연산과 AND, OR와 같은 논리연산을 수행하는 핵심적인 회로입니다.`"
<br>

#### [문제2]<br>'mihykim'은 ALU 구성요소 학습을 마치고 그 내용을 블럭으로 가지런히 정리해두었습니다. 그런데 월요일 아침, 주말에 다녀간 조카가 블럭을 다 빼놓은 것을 발견했습니다. 당황한 'mihykim'을 도와 블럭순서를 바르게 맞춰주세요.
- 산술 연산(+, -, X, %)을 수행하는 장치 : `[ 산술연산장치(AU) ]`
- 논리 연산(&, |, ^, !)을 수행하는 장치 : `[ 논리연산장치(LU) ]`
- 비트들을 좌측 혹은 우측으로 이동시켜주는 레지스터 :  `[ 시프트 레지스터 ]`
- 데이터에 2의 보수를 취해주는 요소 : `[ 보수기(complementer) ]`
- 연산 결과의 상태를 나타내는 플래그들을 저장하는 레지스터 :  `[ 상태 레지스터 ]`
<br>

#### [문제3]<br>컴퓨터구조 스터디원들은 ALU 상태레지스터 내 '상태 플래그'에 대해 서로 공유하기로 하였습니다. 다음 내용 중 사실과는 다른 내용을 이야기하는 사람은 누구일까요? (복수 정답)
```
'jehong'
캐리 플래그(C) 말씀하시는거죠? 처음엔 오버플로우 플래그(O)랑 헷갈렸는데 알아보니 확실히 다른 것이더라구요. 
캐리 플래그는 최상단 비트에서 자리올림 발생 시 Set되고
오버플로우 플래그는 최대 표현 범위를 넘어섰거나, 같은 부호를 더했는데 다른 부호가 나와버릴 때 Set 된답니다.
예를 들어 1000 + 1000 => 10000 에서는 캐리 플래그가,
0111 + 0001 => 1000 에서는 오버플로우가 Set됩니다. (7 + 1 => -8)
```
```
'taelee'
와 다들 잘 알고 계시네요!
지금까지는 상태플래그를 이야기했는데 상태레지스터에는 CPU를 제어하기위해 사용되는 제어플래그(Control flag)도 있답니다. 
그 예로 인터럽트 요구를 받아들일지 말지 결정하는 인터럽트 플래그(I)가 있습니다!
```
<br>

</details>
<br><br>

### 3.2 정수의 표현　　　	`daelee`

#### 부호없는(Unsigned) 정수 표현(책 요약)

- n비트 조합에서 의미있는 조합의 개수 : 2^n 

  - 3bit 라면 000, 001, 010, 011, 100, 101, 110, 111 총 8개의 조합이 가능함.

- n비트에서 표현 가능한 10진수 범위 : 0 ~ 2^n - 1 

- n비트로 표현된 2진수를 10진수로 변환하는 일반식

  ![image-20201129001019628](https://user-images.githubusercontent.com/37580034/100521739-b8f26880-31e8-11eb-8f1a-a16575e65987.png)


- Bit Extension 방법 : 상위(좌측) 남는 비트부터 0추가

  - 8비트를 16비트에 저장헤야할 때 
  - 57(10) = 00111001(8), 0000000000111001(16)
  
#### 부호있는(Signed) 정수 표현(문제)

1. 아래와 같이 부호화-크기(signed-magnitude representation)로 표현된 수들을 10진수로 변환하세요.

   - 0 0110101 = 
   - 1 1010101 = 
   - 1 000 =


2. **부호화-크기** 표현의 가장 큰 단점 두 가지를 설명해주세요. 



3. 1의 보수 표현(1’s complement representation)의 음수화(negation) 방법을 설명해주세요.



4. 2의 보수 표현(2’s complement representation)의 음수화(negation) 방법을 설명해주세요.



5. 2의 보수로 표현된 `10111010`을 10진수로 변환하세요.



   

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
1. 아래와 같이 부호화-크기(signed-magnitude representation)로 표현된 수들을 10진수로 변환하세요.

   - 0 0110101 = 
   - 1 1010101 = 
   - 1 000 =
 

   > 정답 : 
   >
   > - 0 0110101 = 1 * (1x2^5 + 1x2^4 + 1x2^2 + 1x2^0) = (32 + 16 + 4 + 1) = 53  
   > - 1 1010101 = -53
   > - 1 000 = 0

2. **부호화-크기** 표현의 가장 큰 단점 두 가지를 설명해주세요. 

   > 정답 : 
   >
   > 1. n비트 조합에서 의미있는 조합의 개수 : 2^n 가 아니라 2^n - 1 이다. 부호화-크기 표현에서는 1000(2)과 0000(2) 둘 다 0을 표현하므로 **하나의 조합을 낭비하게 된다.**
   > 2. 계산을 수행할 때 **부호비트와 크기 부분을 별도로 처리**해야한다. 크기 부분만 따로 계산한 뒤 크기 부분의 절댓값이 더 큰 수의 부호를 결과값의 부호로 세트해야함. 귀찮음.

3. 1의 보수 표현(1’s complement representation)의 음수화(negation) 방법을 설명해주세요.

   > 정답 : **모든 비트들을 반전한다.** (0 -> 1, 1 -> 0)
   >
   > - 1의 보수 표현에서 **Bit Extension**은 Sign Bit 다음에 Sign Bit와 같은 수를 추가하는 방식으로 이루어진다.
   > - 그러나 여전히 0에 대한 표현이 두 가지이므로 조합의 낭비가 발생한다. 그래서 일반적으로 컴퓨터는 2의 보수 표현법을 더 많이(아니 거의 100%) 사용한다.

4. 2의 보수 표현(2’s complement representation)의 음수화(negation) 방법을 설명해주세요.

   > 정답 : 모든 비트들을 반전하고, **결과값에 1을 더한다.**
   >
   > 1을 더함으로서 조합의 개수를 낭비하지 않게 되었다! 2의 보수 표현에서는 음수0이 사라진 대신, 음수0은 절대값이 가장 큰 음수와 매핑된다. 예를 들어, 100(2)은 부호화-크기 표현에서 음수 0이었지만, 2의보수 표현에서는 -4다.

5. 2의 보수로 표현된 `10111010`을 10진수로 변환하세요.

   > 정답 : **-70**
   >
   > 방법1. 책 145p 예제(3-4) 일반식 참고
   >
   > -  -128 + (1x2^5 + 1x2^4 + 1x2^3 + 1x2^1) = -128 + (32 + 16 + 8 + 2) = -70
   > <br>
   >
   > 방법2. 책 146p 예제(3-6) 참고
   >
   > 1. 10111010 - 1 한 뒤 => 10111001
   > 2.  0은 1로, 1은 0으로 바꿔주기 =>   01000110
   > 3. 10진수로 변환하고 - 부호 붙이기 => -70

   

</details>
<br><br>

### 3.3 논리 연산　　	`sancho`

#### [문제1]<br>선택적 세트 연산이 쓰이는 이유를 설명해주세요.

#### [문제2]<br>선택적 세트 연산을 실행할 A레지스터가 01001100일 때 상위 4비트를 바꾸기 위한 B레지스터의 값을 적어 주세요. 

#### [문제3]<br>선택적 보수 연산이 쓰이는 이유를 설명해주세요.

#### [문제4]<br>선택적 보수 연산을 실행할 A레지스터가 00111001일 때 모든 비트를 바꾸기 위한 B레지스터의 값을 적어 주세요.

#### [문제5]<br>마스크 연산이 쓰이는 이유를 설명해주세요.

#### [문제6]<br>A레지스터가 11001010, B레지스터가 10101100일 때 비교 연산 이후 A레지스터의 값을 적어 주세요.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### [문제1]<br>선택적 세트 연산이 쓰이는 이유를 설명해주세요.
-> 선택적 세트 연산은 어떤 레지스터의 특정 비트들을 1로 세트하려고 할 때 쓰이는 연산으로 A레지스터의 바꿀 비트 위치에 1을 세트하고 OR연산을 수행합니다. 

#### [문제2]<br>선택적 세트 연산을 수행할 A레지스터가 01001100일 때 상위 4비트를 바꾸기 위한 B레지스터의 값을 적어 주세요. 
-> 11110000, 상위 4비트인 앞 네자리에 1로 세팅하여 A레지스터에 선택적 세트 연산을 적용하게 됩니다.

#### [문제3]<br>선택적 보수 연산이 쓰이는 이유를 설명해주세요.
-> 선택적 보수 연산은 레지스터의 특정 비트들을 보수화하기 위한 동작이며 바꿀 A레지스터에 반전시킬 비트 위치에다 1을 세트하고 XOR연산을 수행합니다. 

#### [문제4]<br>선택적 보수 연산을 실행할 A레지스터가 00111001일 때 모든 비트를 바꾸기 위한 B레지스터의 값을 적어 주세요.
-> 11111111, 모든 위치에 1을 세트하여 A레지스터에 선택적 보수 연산을 적용하게 됩니다.

#### [문제5]<br>마스크 연산이 쓰이는 이유를 설명해주세요.
-> 마스크 연산은 데이터 내 특정 비트들의 값을 0으로 리셋시키기 사용하며, 바꿀 A레지스터에 대응되는 비트 위치에 0으로 세트하고 나머지 위치에 1을 세트한 후 AND 연산을 수행합니다.

#### [문제6]<br>A레지스터가 11001010, B레지스터가 10101100일 때 비교 연산 이후 A레지스터의 값을 적어 주세요.
-> 01100110, 같은 자리에 하나씩 비교하며 XOR연산을 진행하면 A레지스터의 값이 다음과 같이 바뀌게 됩니다.

</details>
<br><br>

### 3.4 시프트 연산　　　	`yeosong`


#### 1. 논리적 시프트 LSL, LSR은 부호비트를 복사하지 않으며, 맨 끝에 밀려나는 값은 순환시키지 않고 버린다. (O/X)

#### 2. 논리적 시프트 LSL, LSR은 버리는게 없을 때, 즉 데이터 손실이 없을 때에 좌측 시프트를 한 번 하면 결과가 나누기 2한 값이 된다. (O/X) 

#### 3. 캐리 플래그를 포함한 시프트 연산에서 SHLC는 1번 수행시 최상위 비트를 C플래그에 저장시키게 된다. (O/X)

#### 4. 캐리 플래그를 포함한 시프트 연산에서 SHRC는 1번 수행시 C플래그 값이 최상위 비트로 이동하고, 최하위 비트는 버린다. (O/X)

#### 기본3.7) A 레지스터에 2의 보수로 표현된 데이터 ‘10101101’이 저장되어 있을 때, 산술적 우측 시프트를 두 번 수행한 결과는 다음 중 어느 것인가? 
(보기 편하도록 4비트마다 띄어서 표기하겠습니다)

#### 기본3.8) A 레지스터에 ‘0101 1011’이 저장되어 있을 때, 좌측 순환 시프트를 한 번 수행한 결과는?

#### 기본3.9) A 레지스터에 ‘0101 1011’이 저장되어 있고 C플래그에 1이 저장되어 있을 때, SHRC 연산을 한 번 수행한 결과는? 

#### 기본3.10) A 레지스터에 ‘0101 1011’이 저장되어 있고 C플래그에 ‘0’이 저장되어 있을 때, RLC 연산을 두 번 수행한 결과는?

#### 연습3.8) 8비트 레지스터에 있는 2의 보수 1101 0010을 

1. 논리적 우측 시프트 하면? 
2. 논리적 좌측 시프트 하면? 
3. 순환 우측 시프트 하면? 
4. 순환 좌측 시프트 하면? 
5. 산술적 우측 시프트 하면? 
6. 산술적 좌측 시프트 하면? 

#### 연습3.9) 8비트 레지스터에 있는 2의 보수 1011 0011을 논리적 우측 시프트-> 순환 좌측 시프트-> 산술적 우측 시프트-> 산술적 좌측 시프트 한 결과는?

#### 연습3.10-1) A 레지스터에 1011 0011이 저장되어있고, C플래그 값은 0일때, SHRC 연산 수행 후 값은? 

#### 연습3.10-2) 위의 결과값에 대해 SHLC를 두 번 수행한 값은?

#### 연습3.11-1) 초기 상태에서 어떤 레지스터에 1011 0011이 저장되어 있고, C플래그 값은 1이라고 하자. RLC를 수행한 결과는? 

#### 연습3.11-2) 위의 값에 대해 RRC를 두 번 수행하면?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

#### 1. 논리적 시프트 LSL, LSR은 부호비트를 복사하지 않으며, 맨 끝에 밀려나는 값은 순환시키지 않고 버린다. (O)
#### 2. 논리적 시프트 LSL, LSR은 버리는게 없을 때, 즉 데이터 손실이 없을 때에 좌측 시프트를 한 번 하면 결과가 나누기 2한 값이 된다. (X)
> 앞부분 설명은 맞는데, 곱하기 2한 값이 됩니다. 예를 들면 0010 (2) -> 0100 (4) 
#### 3. 캐리 플래그를 포함한 시프트 연산에서 SHLC는 1번 수행시 최상위 비트를 C플래그에 저장시키게 된다. (O)
#### 4. 캐리 플래그를 포함한 시프트 연산에서 SHRC는 1번 수행시 C플래그 값이 최상위 비트로 이동하고, 최하위 비트는 버린다. (O)
#### 기본3.7) A 레지스터에 2의 보수로 표현된 데이터 ‘10101101’이 저장되어 있을 때, 산술적 우측 시프트를 두 번 수행한 결과는 다음 중 어느 것인가? 
(보기 편하도록 4비트마다 띄어서 표기하겠습니다)

1010 1101 를 ASR하면 <br>
1101 0110. 얘를 한 번 더 ASR하면 <br>
1110 1011이다. 그래서 정답은 <br>
> 1110 1011

#### 기본3.8) A 레지스터에 ‘0101 1011’이 저장되어 있을 때, 좌측 순환 시프트를 한 번 수행한 결과는?
> 최상위의 0이 최하위로 가서 1011 0110

#### 기본3.9) A 레지스터에 ‘0101 1011’이 저장되어 있고 C플래그에 1이 저장되어 있을 때, SHRC 연산을 한 번 수행한 결과는? 

> SHRC = Shift Right with Carry <br>
> 캐리 플래그 1, 0101 1011에서 캐리 플래그의 값이 최상위 비트에 저장되니까 답은 1010 1101.

#### 기본3.10) A 레지스터에 ‘0101 1011’이 저장되어 있고 C플래그에 ‘0’이 저장되어 있을 때, RLC 연산을 두 번 수행한 결과는?

RLC = Rotate Left with Carry <br>
0 0101 1011 에서 한 번 하면<br>
0 1011 0110 , 여기서 한 번 더 하면<br>
> 1 0110 1100

#### 연습3.8) 8비트 레지스터에 있는 2의 보수 1101 0010을 

1. 논리적 우측 시프트 하면?
> 0110 1001
2. 논리적 좌측 시프트 하면?
> 1010 0100
3. 순환 우측 시프트 하면?
> 0110 1001
4. 순환 좌측 시프트 하면?
> 1010 0101
5. 산술적 우측 시프트 하면?
> 1110 1001
6. 산술적 좌측 시프트 하면?
> 1010 0100

#### 연습3.9) 8비트 레지스터에 있는 2의 보수 1011 0011을 논리적 우측 시프트-> 순환 좌측 시프트-> 산술적 우측 시프트-> 산술적 좌측 시프트 한 결과는?

1011 0011을 논리적 우측 시프트 하면 (부호비트 복사 안하고 남는 거 버리고)<br>
0101 1001 그걸 순환 좌측 시프트 하면 (남는 거 순환 시키고)<br>
1011 0010 그걸 산술적 우측 시프트 하면 (부호비트 복사하고, 남는 거는 버리고)<br>
1101 1001 이걸 산술적 좌측 시프트 하면 (한 칸씩 좌측으로 밀고 남는 거는 버리고)<br>
> 1011 0010 

#### 연습3.10-1) A 레지스터에 1011 0011이 저장되어있고, C플래그 값은 0일때, SHRC 연산 수행 후 값은? 
`SHRC` : C플래그의 값이 최상위 비트로 이동하고, 남는 건 버린다. <br>
> 우측이니까 0 1011 0011에서 0 0101 1001

#### 연습3.10-2) 위의 결과값에 대해 SHLC를 두 번 수행한 값은?
`SHLC` :  최상위 비트가 버려지지 않고 C플래그에 저장되고, 원래의 C플래그 값은 지워진다. 남는 건 버린다. <br>
0 0101 1001에서 1회 하면 0 1011 0010. <br>
여기서 한 번 더 하면 1 0110 0100. <br>
> 답은 0110 0100

#### 연습3.11-1) 초기 상태에서 어떤 레지스터에 1011 0011이 저장되어 있고, C플래그 값은 1이라고 하자. RLC를 수행한 결과는? 
`RLC` : 최상위 비트가 버려지지 않고 C플래그에 저장되고, 원래의 C플래그 값은 지워진다. 남는 건 순환<br>
1 1011 0011 -> 1 0110 0111
> 1 0110 0111
 

#### 연습3.11-2) 위의 값에 대해 RRC를 두 번 수행하면?
`RRC` : C플래그의 값이 최상위 비트로 이동, 남는 건 순환 <br>
위의 값인 1 0110 0111에서 <br>
-> 1 1011 0011 <br>
-> 1 1101 1001 <br>

> 1 1101 1001



</details>
<br><br>
