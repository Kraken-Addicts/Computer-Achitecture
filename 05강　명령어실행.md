## 🦄 명령어 실행 (5 / 13회차)
<br>

### 2.2 명령어 실행 - 인출 사이클　　　　　	`daelee`

##### [문제 1] 명령어 사이클에 필요한 레지스터들 입니다. 보기를 참고해 어떤 레지스터에 대한 설명인지 맞춰주세요.

```
[보기] PC, AC, IR, MAR, MBR
```

- `__(a)__` : PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 레지스터
- `__(b)__` : 가장 최근에 인출된 명령어가 저장되어 있는 레지스터
- `__(c)__` : 기억장치에 저장될 데이터 혹은 기억장치로부터 읽혀진 데이터가 일시적으로 저장되는 레지스터
- `__(d)__` : 데이터를 일시적으로 저장하는 레지스터
- `__(e)__` : 다음에 인출될 명령어의 주소를 가지고 있는 레지스터




##### [문제 2] 기억장치로부터 인출된 명령어 코드를 제어 유니트에 의해 해독되기 전에 일시적으로 저장하고 있는 레지스터는 어느 것일까요?

```
가. PC 
나. MAR 
다. IR 
라. AC
```



##### [문제 3] 기억장치 주소가 바이트 단위로 지정되고 명령어 길이는 32비트인 CPU에서는 인출 사이클 동안에 PC가 얼마만큼 증가될까요?

```
가. 1
나. 2 
다. 4 
라. 32
```



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
##### [문제 1] 명령어 사이클에 필요한 레지스터들 입니다. 보기를 참고해 어떤 레지스터에 대한 설명인지 맞춰주세요.

```
[보기] PC, AC, IR, MAR, MBR
```

- `__(a)__` : PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 레지스터
- `__(b)__` : 가장 최근에 인출된 명령어가 저장되어 있는 레지스터
- `__(c)__` : 기억장치에 저장될 데이터 혹은 기억장치로부터 읽혀진 데이터가 일시적으로 저장되는 레지스터
- `__(d)__` : 데이터를 일시적으로 저장하는 레지스터
- `__(e)__` : 다음에 인출될 명령어의 주소를 가지고 있는 레지스터



> **정답** (58p 참고)
>
> (a) : 기억장치 주소 레지스터 (Memory Address Register: `MAR`) 
>
> (b) : 명령어 레지스터 (Instruction Register: `IR`) 
>
> (c) : 기억장치 버퍼 레지스터 (Memory Buffer Register: `MBR`) 
>
> (d) : 누산기(Accumulator: `AC`) 
>
> (e) : 프로그램 카운터(Program Counter: `PC`)



##### [문제 2] 기억장치로부터 인출된 명령어 코드를 제어 유니트에 의해 해독되기 전에 일시적으로 저장하고 있는 레지스터는 어느 것일까요?

```
가. PC 
나. MAR 
다. IR 
라. AC
```

> **정답 : 다** 
>
> 제어 유니트에 보내 해독하면서 실행 사이클이 시작된다. 인출 사이클의 마지막 클록에서 수행하는 작업은 IR <- MBR. 즉 IR로 명령어 코드를 전송한 뒤 실행 사이클로 넘어간다.



##### [문제 3] 기억장치 주소가 바이트 단위로 지정되고 명령어 길이는 32비트인 CPU에서는 인출 사이클 동안에 PC가 얼마만큼 증가될까요?

```
가. 1
나. 2 
다. 4 
라. 32
```

> **정답 : 다** 
>
> 위 환경에서는 한 명령어(32비트)가 주소(8비트) 네 개에 걸쳐 저장되기 때문에 PC는 4씩 증가한다.



##### [인출 사이클 보충 설명]

인출 사이클(fetch cycle): CPU가 기억장치의 지정된 위치(PC가 가리키는)로부터 명렁어를 읽어오는 과정. 

그림 2-4는 인출 사이클 동안에 주소와 명령어 코드가 이동하는 과정을 보여주고 있다. 그림에서 원으로 표시된 기호들은 각 동작이 발생하는 클록의 주기를 나타낸다.

![image](https://user-images.githubusercontent.com/37580034/101347537-97bb0780-38cd-11eb-9957-86cc495942fd.png)

- t<sub>0</sub> : MAR <- PC
  - 현재 PC의 명령어 주소가 MAR을 통해 기억장치로 전송된다. 
- t<sub>1</sub> : MBR <- M[MAR], PC <- PC+1 
  - 기억장치의 해당 주소로부터 읽혀진 명령어 코드가 MBR에 적재된다.
  - 동시에 PC는 1 증가시켜 다음 명령어 주소를 가리키게 한다.
- t<sub>2</sub> : IR <- MBR
  - 명령어 레지스터 IR로 명령어 코드가 전송된다.

</details>
<br><br>

### 2.2 명령어 실행 - 실행 사이클　　　　　　	`sancho`



##### [문제 1] 빈칸에 실행 사이클에서 수행되는 큰 네가지 과정을 맞춰 주세요!

`보기: 데이터 처리, 프로그램 제어, 데이터 이동, 데이터 저장`

- `__(a)__` : CPU와 기억장치 간 혹은 CPU와 I/O 장치 간에 데이터를 불러온다.
- `__(b)__` : 데이터에 대하여 산술 혹은 논리 연산을 수행한다.
- `__(c)__` : 연산결과 데이터 혹은 입력장치로부터 읽어들인 데이터를 기억장치에 쓴다.
- `__(d)__` : 프로그램의 실행순서를 결정한다.
<br>

##### [문제 2] 실행 사이클에서 데이터 인출을 위한 'LOAD addr' 명령어가 실행될 때 빈칸에 들어갈 용어를 적어 주세요!

- t0 : `__(a)__` <- IR(addr)
- t1 : `__(b)__` <- M[MAR]
- t2 : `__(c)__` <- MBR<br>
<br>

##### [문제 3] 실행 사이클에서 데이터 저장을 위한 'STA addr' 명령어가 실행될 때 빈칸에 들어갈 용어를 적어 주세요!

- t0 : `__(a)__` <- IR(addr)
- t1 : `__(b)__` <- AC
- t2 : `__(c)__` <- MBR<br>
<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>



##### [문제 1] 빈칸에 실행 사이클에서 수행되는 큰 네가지 과정을 맞춰 주세요!

`보기: 데이터 처리, 프로그램 제어, 데이터 이동, 데이터 저장`

- `__(a)__` : CPU와 기억장치 간 혹은 CPU와 I/O 장치 간에 데이터를 불러온다.
- `__(b)__` : 데이터에 대하여 산술 혹은 논리 연산을 수행한다.
- `__(c)__` : 연산결과 데이터 혹은 입력장치로부터 읽어들인 데이터를 기억장치에 쓴다.
- `__(d)__` : 프로그램의 실행순서를 결정한다.

 -> a: 데이터 이동, b: 데이터 처리, c: 데이터 저장, d: 프로그램 제어
<br>

##### [문제 2] 실행 사이클에서 데이터 인출을 위한 'LOAD addr' 명령어가 실행될 때 빈칸에 들어갈 용어를 적어 주세요!

- t0 : `__(a)__` <- IR(addr)
- t1 : `__(b)__` <- M[MAR]
- t2 : `__(c)__` <- MBR<br>

 -> a: MAR, b: MBR, c: AC<br>
설명:<br>
첫 번째 주기인 t0에서 명령어 레지스터인 IR에 저장된 주소 addr을 메모리 주소 레지스터인 MAR에 불러오게 되구요.<br>
두 번째 주기인 t1에서 MAR의 데이터를 인출하여 메모리 버퍼 레지스터인 MBR에 저장하게 됩니다.<br>
세 번째 주기인 t2에서 MBR에 저장 된 데이터가 누산기인 AC에 들어가며 데이터를 불러오게 됨으로서 LOAD 명령어의 실행이 완료됩니다.<br>

##### [문제 3] 실행 사이클에서 데이터 저장을 위한 'STA addr' 명령어가 실행될 때 빈칸에 들어갈 용어를 적어 주세요!

- t0 : `__(a)__` <- IR(addr)
- t1 : `__(b)__` <- AC
- t2 : `__(c)__` <- MBR<br>

 -> a: MAR, b: MBR, c: M[MAR]<br>
설명:<br>
첫 번째 주기인 t0에서 명령어 레지스터인 IR에 저장된 주소 addr을 메모리 주소 레지스터인 MAR에 불러오게 되구요.<br>
두 번째 주기인 t1에서 누산기의 결과인 AC의 값을 메모리 버퍼 레지스터인 MBR에 저장시키구요.<br>
세 번째 주기인 t2에서 MBR에 저장 된 데이터를 메모리 주소 레지스터인 MAR의 데이터 저장공간에 저장하게 됨으로서 STA 명령어가 끝나게 됩니다.<br>

</details>
<br><br>

### 2.2 명령어 실행 - 인터럽트 사이클　　　	`yeosong`

#### 쉬어가는 문제 - 프로세서의 예외적인 제어흐름에는 크게 4가지 Interrupt, Trap, Fault, Abort 가 있다. 이들 중 비동기적으로 발생하는 예외 상황은? 

#### 기본 2.7 다음 중 인터럽트 사이클 동안에 수행되는 동작이 아닌 것은?
가. 복귀할 주소를 스택에 저장한다.
나. ISR의 시작 주소를 PC에 적재한다.
다. 인터럽트 요구 신호를 검사한다.
라. 인터럽트 플래그를 세트한다. 

#### 기본 2.8 CPU가 어떤 장치에 대한 인터럽트를 처리하는 도중에 우선순위가 더 낮은 인터럽트 요구가 들어왔습니다. 어떤 일이 발생할까요?


#### 연습 2.2 아래와 같은 어셈블리 프로그램에 대한 기계어 코드들이 200번지부터 저장되어있다.

![표1](https://user-images.githubusercontent.com/53321189/101624974-1e9eea00-3a5e-11eb-906a-7466783d9dfa.png)

1) 위의 프로그램에서 `SUB 301`명령을 실행중인데 개발자 `secho`가 프로세스를 백그라운드로 보내기 위해 `ctrl-z`를 눌렀고, 이 인터럽트 요구는 받아들여졌습니다. 인터럽트 사이클이 종료된 직후, CPU 레지스터들(PC, AC, IR, SP)에는 각각 어떤 값이 저장되어 있나요?
(단, ISR의 시작 주소는 450번지, SP의 초기값은 999라고 가정합니다.)

- `PC` : `____`
- `AC` : `____`
- `IR` : `____`
- `SP` : `____`

2) 이 프로그램이 순차적으로 실행되는 경우를 고려해 아래 표를 완성해보세요. 기억장치 300번지에는 9가, 301번지에는 5가 저장되어 있습니다.

![뮨제](https://user-images.githubusercontent.com/53321189/101624971-1e065380-3a5e-11eb-83c8-32bccbf7c018.png)

#### 연습 2.3 인터럽트 사이클이 그림2-9(b)와 같이 종료된 후 처리되는 인터럽트 서비스 루틴에서 `누산기`의 내용을 스택에 저장하였다.
1) 그 값이 저장되는 기억장치의 주소는 몇번지일까? `____`
2) SP의 내용은 어떤 값으로 변경되는가? `____`

#### 연습 2.4 인터럽트 서비스 루틴을 수행하는 도중에 더 높은 우선순위를 가진 인터럽트 요구가 들어오더라도 그 루틴의 수행이 중단되지 않도록 하는 방법은?


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
#### 인터럽트 enabled 상태에서 인터럽트 요구가 들어왔다. 인터럽트 사이클 동안 수행되는 동작을 마이크로 연산으로 표현해보세요.

#### 쉬어가는 문제 - 프로세서의 예외적인 제어흐름에는 크게 4가지 Interrupt, Trap, Fault, Abort 가 있다. 이들 중 비동기적으로 발생하는 예외 상황은? 
> 인터럽트. 특정 인스트럭션을 수행하다가 생기는 것이 아니기 때문이다.

#### 기본 2.7 다음 중 인터럽트 사이클 동안에 수행되는 동작이 아닌 것은?
가. 복귀할 주소를 스택에 저장한다.
> 예) MBR ← PC : 인터럽트 처리 완료 후에 복귀할 곳을 저장하기 위해, 현재의 PC내용을 스택에 저장한다.
나. ISR의 시작 주소를 PC에 적재한다.
> 예) PC ← ISR의 시작 주소 : 인터럽트 처리 루틴의 시작 주소를 PC에 담는다.
다. 인터럽트 요구 신호를 검사한다.
> 인터럽트가 요구가 있는지 확인하고, Interrupt enabled이면 실행한다.
라. 인터럽트 플래그를 세트한다. **(X)** 
> 라. 사이클 내에 항상 이루어질 필요는 없으며, 필요에 따라 삽입한다.

#### 기본 2.8 CPU가 어떤 장치에 대한 인터럽트를 처리하는 도중에 우선순위가 더 낮은 인터럽트 요구가 들어왔습니다. 어떤 일이 발생할까요?

> 현재 인터럽트 서비스 루틴의 수행을 계속한다.


#### 연습 2.2 아래와 같은 어셈블리 프로그램에 대한 기계어 코드들이 200번지부터 저장되어있다.

![표1](https://user-images.githubusercontent.com/53321189/101624974-1e9eea00-3a5e-11eb-906a-7466783d9dfa.png)

1) 위의 프로그램에서 `SUB 301`명령을 실행중인데 개발자 `secho`가 프로세스를 백그라운드로 보내기 위해 `ctrl-z`를 눌렀고, 이 인터럽트 요구는 받아들여졌습니다. 인터럽트 사이클이 종료된 직후, CPU 레지스터들(PC, AC, IR, SP)에는 각각 어떤 값이 저장되어 있나요?
(단, ISR의 시작 주소는 450번지, SP의 초기값은 999라고 가정합니다.)

- `PC` : `0450`
- `AC` : `0004`
- `IR` : `6301`
- `SP` : `0998`

2 )이 프로그램이 순차적으로 실행되는 경우를 고려해 아래 표를 완성해보세요. 기억장치 300번지에는 9가, 301번지에는 5가 저장되어 있습니다.

![답](https://user-images.githubusercontent.com/53321189/101624962-1b0b6300-3a5e-11eb-8dc8-acad6e9f621d.png)


#### 연습 2.3 인터럽트 사이클이 그림2-9(b)와 같이 종료된 후 처리되는 인터럽트 서비스 루틴에서 `누산기`의 내용을 스택에 저장하였다.
1) 그 값이 저장되는 기억장치의 주소는 몇번지일까? `0998`
2 )SP의 내용은 어떤 값으로 변경되는가? `0997`

#### 연습 2.4 인터럽트 서비스 루틴을 수행하는 도중에 더 높은 우선순위를 가진 인터럽트 요구가 들어오더라도 그 루틴의 수행이 중단되지 않도록 하는 방법은?

> 인터럽트 서비스 루틴을 시작할 때 인터럽트 disabled를 켜고, 루틴을 종료할 때 enabled로 바꾼다.



</details>
<br><br>

### 2.2 명령어 실행 - 간접 사이클　　　	`kycho`

요기엔 문제를 적어주세연-

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>
