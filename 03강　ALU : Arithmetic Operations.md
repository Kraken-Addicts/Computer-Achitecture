## 🦄 ALU: Arithmetic Operations (3 / 13회차)
<br>

### 3.5 정수의 산술 연산　　　	`kycho`

#### [문제1]<br>다음 문장은 덧셈을 수행하는 하드웨어에 관한 설명입니다. 빈칸에 알맞는 답을 적으세요.
- `1)_____`는 여러 비트들로 이루어진 두 개의 데이터에 대한 덧셈을 수행하는 회로로서, 비트 수 만큼의 `2)_____`들로 구성이 되어있다.<br>
`2)_____`들은 `3)_____`를 전송하는 선에 의해 연결되어있다. 
<br>

#### [문제2]<br>다음 그림은 상태비트 제어회로가 포함된 4비트 병렬가산기의 구성도 입니다. 빨간박스로 표시된 상태비트 (1),(2),(3),(4)의 명칭과 간단한 설명을 작성하세요.
![image](https://user-images.githubusercontent.com/26676051/100917870-148b6180-351b-11eb-8e90-1af5e8b6cdf5.png)

<br>

#### [문제3]<br>다음은 정수의 덧셈과 뺄셈에 대한 설명입니다. 틀린것을 모두 고르세요.
- 가) 2의 보수로 표현된 수들 간의 덧셈에서 올림수가 발생하면, 올림수를 버리고 결과값을 사용한다. 
- 나) 덧셈 과정에서 수의 표현 범위를 초과하는 경우에도 올바른 결과를 산출하게된다. 
- 다) 정수들의 뺄셈은 덧셈을 이용하여 수행할수 있다. 
- 라) 일반적으로 ALU에 뺄셈을 위한 회로를 별도로 두고 뺄셈을 수행한다. 

<br>

#### [문제4]<br>다음 그림은 부호 없는 2진수 곱셈기의 구성도 입니다. 그림을 참고하여 아래의 물음에 답하세요.
![image](https://user-images.githubusercontent.com/26676051/100918035-4f8d9500-351b-11eb-82ec-6b24bb157214.png)
1) Q레지스터의 최하위 비트(Q<sub>0</sub>)가 1이면,  별도의 작업없이 C-A-Q레지스터의 모든 비트를 한비트씩 우측 시프트 시킨다. (O / X)
2) 최종 연산의 결과는 A레지스터에 담겨있다. (O / X)
3) 두개의 4비트 정수들을 곱하면 4번의 시프트가 발생한다 (O / X)
4) 1101 X 0101 을 수행할때,  C, A, Q, M 레지스터의 초기 상태를 구하여라.
5) 1101 X 0101 을 수행할때,  C, A, Q, M 레지스터의 종료 상태를 구하여라.
6) 1101 X 0101 의 결과값을 구하여라.

<br>

#### [문제5]<br>2의 보수들 간의 곱셈을 위해 고안된 알고리즘 중 가장 널리 사용되고 있는 알고리즘은 Booth 알고리즘입니다.<br>Booth 알고리즘을 구현한 Booth 곱셈기와 부호 없는 2진수 곱셈기를 구성할때 차이점 2가지는 무엇인가요?

<br>

#### [문제6]<br>다음 그림은 Booth 알고리즘의 흐름도입니다. 빈칸에 알맞는 식을 써넣으세요.
![image](https://user-images.githubusercontent.com/26676051/100916211-cd03d600-3518-11eb-86b6-79502ab40e82.png)

<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

#### [문제1]<br>다음 문장은 덧셈을 수행하는 하드웨어에 관한 설명입니다. 빈칸에 알맞는 답을 적으세요.
- `1) 병렬 가산기(parallel adder)`는 여러 비트들로 이루어진 두 개의 데이터에 대한 덧셈을 수행하는 회로로서, 비트 수 만큼의 `2) 전가산기(full-adder)`들로 구성이 되어있다.<br>
`2) 전가산기(full-adder)`들은 `3) 올림수 비트(carry bit)`를 전송하는 선에 의해 연결되어있다. 
<br>

#### [문제2]<br>다음 그림은 상태비트 제어회로가 포함된 4비트 병렬가산기의 구성도 입니다. 빨간박스로 표시된 상태비트 (1),(2),(3),(4) 명칭과 간단한 설명을 작성하세요.
![image](https://user-images.githubusercontent.com/26676051/100917870-148b6180-351b-11eb-8e90-1af5e8b6cdf5.png)
<br>

> (1) 오버플로우(V) 플래그 :  최상위 캐리비트 2개를 XOR한 값으로 세트하며(V = C<sub>4</sub> XOR C<sub>3</sub>), 오버플로우가 발생했는지 판단한다. 오버플로우가 발생하면 1로 세트된다.<br>
(2) 영(Z) 플래그 : 합의 모든 비트들을 NOR 게이트를 통과시켜서, 0인지 아닌지 판단한다. 합의 모든 비트들이 0이면 1로 세트된다.<br>
(3) 부호(S) 플래그 : 부호비트인 합의 최상위 비트와 직접 연결되며, 양수이면 0 음수이면 1로 세트된다.<br>
(4) 올림수(C) 플래그 : 최상위 단계의 전가산기로부터 발생하는 올림수(C<sub>4</sub>)에 의해서 세트된다.<br>

<br>

#### [문제3]<br>다음은 정수의 덧셈과 뺄셈에 대한 설명입니다. 틀린것을 모두 고르세요.
- 가) 2의 보수로 표현된 수들 간의 덧셈에서 올림수가 발생하면, 올림수를 버리고 결과값을 사용한다. 
- 나) 덧셈 과정에서 수의 표현 범위를 초과하는 경우에도 올바른 결과를 산출하게된다. 
- 다) 정수들의 뺄셈은 덧셈을 이용하여 수행할수 있다. 
- 라) 일반적으로 ALU에 뺄셈을 위한 회로를 별도로 두고 뺄셈을 수행한다. 
```
나), 라) 틀렸다. 
```
> 나)<br> 덧셈 과정에서 수의 푸현 범위를 초과하는 경우에는 전혀 틀린 결과를 산출하게 된다.<br>예를 들어서 4비트 데이터인 0110(6)과 0011(3)을 더하게 되면 0110 + 0011 = 1001(-7)이 나오게된다. <br>이것을 오버플로우(overflow)라고 한다.<br><br>
라)<br> 뺄셈은 덧셈을 이용하여 수행된다. 그러므로 일반적으로 ALU에 뺄셈을 위한 회로를 별도로 두지 않고 가산기를 이용하여 뺄셈을 수행한다.<br>
아래의 이미지처럼 보수기를 이용해서 덧셈과 뺄샘을 겸용으로 사용할수 있는 회로를 구성한다.<br> 
![image](https://user-images.githubusercontent.com/26676051/100921955-96ca5480-3520-11eb-842d-35f4c0783f6d.png)
<br>

#### [문제4]<br>다음 그림은 부호 없는 2진수 곱셈기의 구성도 입니다. 그림을 참고하여 아래의 물음에 답하세요.
![image](https://user-images.githubusercontent.com/26676051/100918035-4f8d9500-351b-11eb-82ec-6b24bb157214.png)
1) Q레지스터의 최하위 비트(Q<sub>0</sub>)가 1이면,  별도의 작업없이 C-A-Q레지스터의 모든 비트를 한비트씩 우측 시프트 시킨다. (O / X)
> 답 : X <br>
제어 회로는 Q<sub>0</sub>비트를 검사하고, Q<sub>0</sub> = 1인 경우에는 M레지스터 A레지스터의 덧셈을 수행하게 한뒤 C-A-Q레지스터의 모든 비트를 우측으로 한비트씩 시프트 시킨다. Q<sub>0</sub> = 0 인경우에는 덧셈을 수행하지 않고 바로 시프트 시킨다. 

2) 최종 연산의 결과는 A레지스터에 담겨있다. (O / X)
> 답 : X <br>
연산의 최종 결과는 A-Q레지스터에 담겨있다. 

3) 두개의 4비트 정수들을 곱하면 4번의 시프트가 발생한다 (O / X)
> 답 : O <br>
n비트의 경우 n번의 우측 시프트 연산이 일어난다. 

4) 1101 X 0101 을 수행할때,  C, A, Q, M 레지스터의 초기 상태를 구하여라.
>  C : 0    (0으로 초기화)<br>
A : 0000 (0으로 초기화)<br>
Q : 0101 (승수로 초기화)<br>
M : 1101 (피승수로 초기화)

5) 1101 X 0101 을 수행할때,  C, A, Q, M 레지스터의 종료 상태를 구하여라.
>  C : 0    <br>
A : 0100 <br>
Q : 0001 <br>
M : 1101 (피승수, 변함없음)

|             | C    | A    | Q    |                                                      |
| ----------- | ---- | :--- | ---- | ---------------------------------------------------- |
| [초기 상태] | 0    | 0000 | 0101 |                                                      |
| [사이클 1]  | 0    | 1101 | 0101 | Q<sub>0</sub> = 1 이므로, A ← A + M                  |
|             | 0    | 0110 | 1010 | 우측 시프트( C-A-Q)                                  |
| [사이클 2]  | 0    | 0011 | 0101 | Q<sub>0</sub> = 0 이므로, 우측 시프트( C-A-Q)만 수행 |
| [사이클 3]  | 1    | 0000 | 0101 | Q<sub>0</sub> = 1 이므로, A ← A + M                  |
|             | 0    | 1000 | 0010 | 우측 시프트( C-A-Q)                                  |
| [사이클 4]  | 0    | 0100 | 0001 | Q<sub>0</sub> = 0 이므로, 우측 시프트( C-A-Q)만 수행 |

6) 1101 X 0101 의 결과값을 구하여라.
> 답 : 65<br>
A-Q레지스터의 값이 01000001(65)이다.<br>
1101(13) X 0101(5) = 01000001(65)

<br>

#### [문제5]<br>2의 보수들 간의 곱셈을 위해 고안된 알고리즘 중 가장 널리 사용되고 있는 알고리즘은 Booth 알고리즘입니다.<br>Booth 알고리즘을 구현한 Booth 곱셈기와 부호 없는 2진수 곱셈기를 구성할때 차이점 2가지는 무엇인가요?

> (1) M레지스터와 병렬 가산기 사이에 보수기(complementer)를 추가한다. <br><br> (2) Q레지스터 오른쪽에 Q<sub>-1</sub>이라고 부르는 1비트 레지스터를 추가하고, Q<sub>0</sub>와 함께 제어 회로로 입력되도록 한다. <br>  (Q레지스터가 우측 시프트 될때, Q<sub>0</sub> 비트가 Q<sub>-1</sub>레지스터에 저장된다.) 

<br>

#### [문제6]<br>다음 그림은 Booth 알고리즘의 흐름도입니다. 빈칸에 알맞는 식을 써넣으세요.
![image](https://user-images.githubusercontent.com/26676051/100916211-cd03d600-3518-11eb-86b6-79502ab40e82.png)
> (1) A ← A - M<br>
(2) A ← A + M
<br>

</details>
<br><br>

### 3.6 부동소수점 수의 표현　　　　	`jakang`

요기엔 문제를 적어주세연-

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  
답지의 구성은<br>
문제와 동일하게 부탁드려연-

</details>
<br><br>

### 3.7 부동소수점 산술 연산　　	`gaekim`

```
[부동소수점 산술 연산 개념정리]

1. 덧셈 / 뺄셈

    1단계. 두 수의 지수가 같아지도록 만든다(소수점의 위치를 이동)

    2단계. 가수들끼리 덧셈 / 뺄셈한다

    3단계. 결과값을 정규화한다.(가수의 숫자가 소숫점 첫째자리에서 시작하도록)

          예시) 1.001001 x 2^5 → 0.1001001 x 2^6

2. 곱셈 / 나눗셈

    1단계. 가수끼리 곱한다

    2단계. 지수끼리 더하거나(곱셈) 뺀다(나눗셈)

    3단계. 정규화한다.
 ```   
    

- 다음 중 부동소수점 덧셈 과정에서 필요하지 않은 연산은 어느 것인가? [기본문제 3.15번]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 가. 지수 조정 &nbsp;&nbsp;&nbsp; 나. 정규화 &nbsp;&nbsp;&nbsp; 다. 지수 덧셈 &nbsp;&nbsp;&nbsp; 라. 가수 덧셈
- 다음 중 부동소수점 나눗셈 과정에서 필요하지 않은 연산은 어느 것인가? [기본문제 3.16번]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 가. 지수 조정 &nbsp;&nbsp;&nbsp; 나. 정규화 &nbsp;&nbsp;&nbsp; 다. 가수 나누기 &nbsp;&nbsp;&nbsp; 라. 지수 뺄셈
- 아래의 부동소수점 산술 연산들을 수행하라. [연습문제 3.24번 변형]


  1번>  (0.111001 x 2<sup>-5</sup>) + (0.100111 x 2<sup>-3</sup>)
  
  
  2번>  (0.100011 x 2<sup>6</sup>) - (0.111001 x 2<sup>3</sup>)
  
  
  3번>  (0.1001 x 2<sup>8</sup>) x (0.1011 x 2<sup>12</sup>)
- 부동소수점 산술연산 과정에서는 `__` 오버플로우, `__` 언더플로우, `__` 언더플로우, `__` 오버플로우 등의 문제가 발생할 가능성이 있다.


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  

- 다음 중 부동소수점 덧셈 과정에서 필요하지 않은 연산은 어느 것인가? [기본문제 3.15번]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 가. 지수 조정 &nbsp;&nbsp;&nbsp; 나. 정규화 &nbsp;&nbsp;&nbsp; **다. 지수 덧셈** &nbsp;&nbsp;&nbsp; 라. 가수 덧셈
- 다음 중 부동소수점 나눗셈 과정에서 필요하지 않은 연산은 어느 것인가? [기본문제 3.16번]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **가. 지수 조정** &nbsp;&nbsp;&nbsp; 나. 정규화 &nbsp;&nbsp;&nbsp; 다. 가수 나누기 &nbsp;&nbsp;&nbsp; 라. 지수 뺄셈
- 아래의 부동소수점 산술 연산들을 수행하라. [연습문제 3.24번 변형]


  1번>  (0.111001 x 2<sup>-5</sup>) + (0.100111 x 2<sup>-3</sup>) = **0.11010101 x 2<sup>-3</sup>**
  
  
  2번>  (0.100011 x 2<sup>6</sup>) - (0.111001 x 2<sup>3</sup>) = **0.11011111 x 2<sup>5</sup>**
  
  
  3번>  (0.1001 x 2<sup>8</sup>) x (0.1011 x 2<sup>12</sup>) = **0.1100011 x 2<sup>19</sup>**
  
  <img src = "https://user-images.githubusercontent.com/59970070/100898551-388f7880-3504-11eb-9ef7-d292843994be.jpg" width="70%" height="70%">

- 부동소수점 산술연산 과정에서는 `지수` 오버플로우, `지수` 언더플로우, `가수` 언더플로우, `가수` 오버플로우 등의 문제가 발생할 가능성이 있다.
   > 표현할 수 있는 범위를 넘어설 경우, 위와 같은 문제들이 발생할 수 있다.
</details>
<br><br>
