## 🦄 ALU: Arithmetic Operations (3 / 13회차)
<br>

### 3.5 정수의 산술 연산　　　	`kycho`

#### [문제1]<br>다음 문장은 덧셈을 수행하는 하드웨어에 관한 설명입니다. 빈칸에 알맞는 답을 적으세요.
- `1)_____`는 여러 비트들로 이루어진 두 개의 데이터에 대한 덧셈을 수행하는 회로로서, 비트 수 만큼의 `2)_____`들로 구성이 되어있다.<br>
`2)_____`들은 `3)_____`를 전송하는 선에 의해 연결되어있다. 
<br>

#### [문제2]<br>다음 그림은 상태비트 제어회로가 포함된 4비트 병렬가산기의 구성도 입니다. 빨간박스로 표시된 상태비트 (1),(2),(3),(4)의 명칭과 간단한 설명을 작성하세요.
![image](https://user-images.githubusercontent.com/26676051/100917870-148b6180-351b-11eb-8e90-1af5e8b6cdf5.png)

<br>

#### [문제3]<br>다음은 정수의 덧셈과 뺄셈에 대한 설명입니다. 틀린것을 모두 고르세요.
- 가) 2의 보수로 표현된 수들 간의 덧셈에서 올림수가 발생하면, 올림수를 버리고 결과값을 사용한다. 
- 나) 덧셈 과정에서 수의 표현 범위를 초과하는 경우에도 올바른 결과를 산출하게된다. 
- 다) 정수들의 뺄셈은 덧셈을 이용하여 수행할수 있다. 
- 라) 일반적으로 ALU에 뺄셈을 위한 회로를 별도로 두고 뺄셈을 수행한다. 

<br>

#### [문제4]<br>다음 그림은 부호 없는 2진수 곱셈기의 구성도 입니다. 그림을 참고하여 아래의 물음에 답하세요.
![image](https://user-images.githubusercontent.com/26676051/100918035-4f8d9500-351b-11eb-82ec-6b24bb157214.png)
1) Q레지스터의 최하위 비트(Q<sub>0</sub>)가 1이면,  별도의 작업없이 C-A-Q레지스터의 모든 비트를 한비트씩 우측 시프트 시킨다. (O / X)
2) 최종 연산의 결과는 A레지스터에 담겨있다. (O / X)
3) 두개의 4비트 정수들을 곱하면 4번의 시프트가 발생한다 (O / X)
4) 1101 X 0101 을 수행할때,  C, A, Q, M 레지스터의 초기 상태를 구하여라.
5) 1101 X 0101 을 수행할때,  C, A, Q, M 레지스터의 종료 상태를 구하여라.
6) 1101 X 0101 의 결과값을 구하여라.

<br>

#### [문제5]<br>2의 보수들 간의 곱셈을 위해 고안된 알고리즘 중 가장 널리 사용되고 있는 알고리즘은 Booth 알고리즘입니다.<br>Booth 알고리즘을 구현한 Booth 곱셈기와 부호 없는 2진수 곱셈기를 구성할때 차이점 2가지는 무엇인가요?

<br>

#### [문제6]<br>다음 그림은 Booth 알고리즘의 흐름도입니다. 빈칸에 알맞는 식을 써넣으세요.
![image](https://user-images.githubusercontent.com/26676051/100916211-cd03d600-3518-11eb-86b6-79502ab40e82.png)

<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

#### [문제1]<br>다음 문장은 덧셈을 수행하는 하드웨어에 관한 설명입니다. 빈칸에 알맞는 답을 적으세요.
- `1) 병렬 가산기(parallel adder)`는 여러 비트들로 이루어진 두 개의 데이터에 대한 덧셈을 수행하는 회로로서, 비트 수 만큼의 `2) 전가산기(full-adder)`들로 구성이 되어있다.<br>
`2) 전가산기(full-adder)`들은 `3) 올림수 비트(carry bit)`를 전송하는 선에 의해 연결되어있다. 
<br>

#### [문제2]<br>다음 그림은 상태비트 제어회로가 포함된 4비트 병렬가산기의 구성도 입니다. 빨간박스로 표시된 상태비트 (1),(2),(3),(4) 명칭과 간단한 설명을 작성하세요.
![image](https://user-images.githubusercontent.com/26676051/100917870-148b6180-351b-11eb-8e90-1af5e8b6cdf5.png)
<br>

> (1) 오버플로우(V) 플래그 :  최상위 캐리비트 2개를 XOR한 값으로 세트하며(V = C<sub>4</sub> XOR C<sub>3</sub>), 오버플로우가 발생했는지 판단한다. 오버플로우가 발생하면 1로 세트된다.<br>
(2) 영(Z) 플래그 : 합의 모든 비트들을 NOR 게이트를 통과시켜서, 0인지 아닌지 판단한다. 합의 모든 비트들이 0이면 1로 세트된다.<br>
(3) 부호(S) 플래그 : 부호비트인 합의 최상위 비트와 직접 연결되며, 양수이면 0 음수이면 1로 세트된다.<br>
(4) 올림수(C) 플래그 : 최상위 단계의 전가산기로부터 발생하는 올림수(C<sub>4</sub>)에 의해서 세트된다.<br>

<br>

#### [문제3]<br>다음은 정수의 덧셈과 뺄셈에 대한 설명입니다. 틀린것을 모두 고르세요.
- 가) 2의 보수로 표현된 수들 간의 덧셈에서 올림수가 발생하면, 올림수를 버리고 결과값을 사용한다. 
- 나) 덧셈 과정에서 수의 표현 범위를 초과하는 경우에도 올바른 결과를 산출하게된다. 
- 다) 정수들의 뺄셈은 덧셈을 이용하여 수행할수 있다. 
- 라) 일반적으로 ALU에 뺄셈을 위한 회로를 별도로 두고 뺄셈을 수행한다. 
```
나), 라) 틀렸다. 
```
> 나)<br> 덧셈 과정에서 수의 푸현 범위를 초과하는 경우에는 전혀 틀린 결과를 산출하게 된다.<br>예를 들어서 4비트 데이터인 0110(6)과 0011(3)을 더하게 되면 0110 + 0011 = 1001(-7)이 나오게된다. <br>이것을 오버플로우(overflow)라고 한다.<br><br>
라)<br> 뺄셈은 덧셈을 이용하여 수행된다. 그러므로 일반적으로 ALU에 뺄셈을 위한 회로를 별도로 두지 않고 가산기를 이용하여 뺄셈을 수행한다.<br>
아래의 이미지처럼 보수기를 이용해서 덧셈과 뺄샘을 겸용으로 사용할수 있는 회로를 구성한다.<br> 
![image](https://user-images.githubusercontent.com/26676051/100921955-96ca5480-3520-11eb-842d-35f4c0783f6d.png)
<br>

#### [문제4]<br>다음 그림은 부호 없는 2진수 곱셈기의 구성도 입니다. 그림을 참고하여 아래의 물음에 답하세요.
![image](https://user-images.githubusercontent.com/26676051/100918035-4f8d9500-351b-11eb-82ec-6b24bb157214.png)
1) Q레지스터의 최하위 비트(Q<sub>0</sub>)가 1이면,  별도의 작업없이 C-A-Q레지스터의 모든 비트를 한비트씩 우측 시프트 시킨다. (O / X)
> 답 : X <br>
제어 회로는 Q<sub>0</sub>비트를 검사하고, Q<sub>0</sub> = 1인 경우에는 M레지스터 A레지스터의 덧셈을 수행하게 한뒤 C-A-Q레지스터의 모든 비트를 우측으로 한비트씩 시프트 시킨다. Q<sub>0</sub> = 0 인경우에는 덧셈을 수행하지 않고 바로 시프트 시킨다. 

2) 최종 연산의 결과는 A레지스터에 담겨있다. (O / X)
> 답 : X <br>
연산의 최종 결과는 A-Q레지스터에 담겨있다. 

3) 두개의 4비트 정수들을 곱하면 4번의 시프트가 발생한다 (O / X)
> 답 : O <br>
n비트의 경우 n번의 우측 시프트 연산이 일어난다. 

4) 1101 X 0101 을 수행할때,  C, A, Q, M 레지스터의 초기 상태를 구하여라.
>  C : 0    (0으로 초기화)<br>
A : 0000 (0으로 초기화)<br>
Q : 0101 (승수로 초기화)<br>
M : 1101 (피승수로 초기화)

5) 1101 X 0101 을 수행할때,  C, A, Q, M 레지스터의 종료 상태를 구하여라.
>  C : 0    <br>
A : 0100 <br>
Q : 0001 <br>
M : 1101 (피승수, 변함없음)

|             | C    | A    | Q    |                                                      |
| ----------- | ---- | :--- | ---- | ---------------------------------------------------- |
| [초기 상태] | 0    | 0000 | 0101 |                                                      |
| [사이클 1]  | 0    | 1101 | 0101 | Q<sub>0</sub> = 1 이므로, A ← A + M                  |
|             | 0    | 0110 | 1010 | 우측 시프트( C-A-Q)                                  |
| [사이클 2]  | 0    | 0011 | 0101 | Q<sub>0</sub> = 0 이므로, 우측 시프트( C-A-Q)만 수행 |
| [사이클 3]  | 1    | 0000 | 0101 | Q<sub>0</sub> = 1 이므로, A ← A + M                  |
|             | 0    | 1000 | 0010 | 우측 시프트( C-A-Q)                                  |
| [사이클 4]  | 0    | 0100 | 0001 | Q<sub>0</sub> = 0 이므로, 우측 시프트( C-A-Q)만 수행 |

6) 1101 X 0101 의 결과값을 구하여라.
> 답 : 65<br>
A-Q레지스터의 값이 01000001(65)이다.<br>
1101(13) X 0101(5) = 01000001(65)

<br>

#### [문제5]<br>2의 보수들 간의 곱셈을 위해 고안된 알고리즘 중 가장 널리 사용되고 있는 알고리즘은 Booth 알고리즘입니다.<br>Booth 알고리즘을 구현한 Booth 곱셈기와 부호 없는 2진수 곱셈기를 구성할때 차이점 2가지는 무엇인가요?

> (1) M레지스터와 병렬 가산기 사이에 보수기(complementer)를 추가한다. <br><br> (2) Q레지스터 오른쪽에 Q<sub>-1</sub>이라고 부르는 1비트 레지스터를 추가하고, Q<sub>0</sub>와 함께 제어 회로로 입력되도록 한다. <br>  (Q레지스터가 우측 시프트 될때, Q<sub>0</sub> 비트가 Q<sub>-1</sub>레지스터에 저장된다.) 

<br>

#### [문제6]<br>다음 그림은 Booth 알고리즘의 흐름도입니다. 빈칸에 알맞는 식을 써넣으세요.
![image](https://user-images.githubusercontent.com/26676051/100916211-cd03d600-3518-11eb-86b6-79502ab40e82.png)
> (1) A ← A - M<br>
(2) A ← A + M
<br>

</details>
<br><br>

### 3.6 부동소수점 수의 표현　　　　	`jakang`

#### [문제1]<br>
다음은 kycho가 IEEE 754 표준 32비트 부동소수점에 대한 특징을 논한 것이다. 설명 중 틀린 항목의 갯수는? <br><br>
(가) 표준에 따르면 32비트 단일-정밀도 형식의 경우, 부호 (S) 1비트, 지수 (E) 8비트, 가수 (M) 23비트로 구성되어 있어. <br>
(나) 지수 필드는 바이어스 된 2진수로 표현되어 있는데, 이 때 바이어스 값은 127이야. <br>
(다) 그렇다면 지수 필드 패턴이 0000_0000일 때, 실제 지수 값은 바이어스 값 127을 뺀 -127이라고 할 수 있겠군! <br>
(라) 이 경우 2<sup>-127</sup>이므로, (가수) 값에 상관없이 0에 가까운 아주 작은 값을 표현하게 되는 셈이군. <br>
(마) 표준에서는 가수는 1.M X 2<sup>E-127</sup>의 형태를 가지는데, 여기서 소수점 위의 1은 숨겨진 비트라고 부르고, 가수 필드에는 나타내지 않는다고 하네.
<br>

#### [문제2]<br>
다음은 jakang이 10진수 '-253.25'를 IEEE 754 표준 32비트 부동소수점 형식으로 표현하는 과정을 나타내었다. 절차 중 틀린 항목의 갯수는? <br><br>
(가) 먼저 음수이므로, 부호 (S) 필드는 1이겠네.<br>
(나) 253.25는 11111101.01<sub>(2)</sub>이므로, 1.111110101 X 2<sup>7</sup>으로 정리할 수 있겠군.<br>
(다) 그렇다면 지수 (E) 필드는 0000_0111에다가 바이어스 127인 0111_1111을 더한 1000_0110 이겠군.<br>
(라) 가수 (M) 필드는 1111_1101_0100_0000_0000_000이네.<br>
(마) 이를 전부 합치면 1 1000_0110 1111_1101_0100_0000_000 이겠군. <br>
<br>

#### [문제3]<br>
부동소수점 표현으로는 ’0’을 나타낼 수 없는 이유를 설명하고, IEEE 754 표준 32-비트 부동소수점 형식에서의 ‘0’에 대한 비트 패턴을 표시하세요.
<br>

#### [문제4]<br>
10진수 '-1.625'를 IEEE 754 표준 32비트 부동소수점 형식으로 표현하세요.
<br>


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>

#### [문제1] 주어진 보기는 모두 맞다<br>
다음은 kycho가 IEEE 754 표준 32비트 부동소수점에 대한 특징을 논한 것이다. 설명 중 틀린 항목의 갯수는? <br><br>
(가) (ㅇ) 표준에 따르면 32비트 단일-정밀도 형식의 경우, 부호 (S) 1비트, 지수 (E) 8비트, 가수 (M) 23비트로 구성되어 있어. <br>
(나) (ㅇ) 지수 필드는 바이어스 된 2진수로 표현되어 있는데, 이 때 바이어스 값은 127이야. <br>
(다) (ㅇ) 그렇다면 지수 필드 패턴이 0000_0000일 때, 실제 지수 값은 바이어스 값 127을 뺀 -127이라고 할 수 있겠군! <br>
(라) (ㅇ) 이 경우 2<sup>-127</sup>이므로, (가수) 값에 상관없이 0에 가까운 아주 작은 값을 표현하게 되는 셈이군. <br>
(마) (ㅇ) 표준에서는 가수는 1.M X 2<sup>E-127</sup>의 형태를 가지는데, 여기서 소수점 위의 1은 숨겨진 비트라고 부르고, 가수 필드에는 나타내지 않는다고 하네.
<br>

#### [문제2] (라)와 (마)가 틀렸다 <br>
다음은 jakang이 10진수 '-253.25'를 IEEE 754 표준 32비트 부동소수점 형식으로 표현하는 과정을 나타내었다. 절차 중 틀린 항목의 갯수는?<br><br>
(가) (ㅇ) 먼저 음수이므로, 부호 (S) 필드는 1이겠네.<br>
(나) (ㅇ) 253.25는 11111101.01<sub>(2)</sub>이므로, 1.111110101 X 2<sup>7</sup>으로 정리할 수 있겠군.<br>
(다) (ㅇ) 그렇다면 지수 (E) 필드는 0000_0111에다가 바이어스 127인 0111_1111을 더한 1000_0110 이겠군.<br>
(라) (X) 가수 (M) 필드는 1111_1101_0100_0000_0000_000이네.<br>
(마) (X) 이를 전부 합치면 1 1000_0110 1111_1101_0100_0000_000 이겠군. <br>
<br> 가수 필드의 젤 첫 비트인 1은 숨겨진 비트이므로 생략. 즉, 111_1101_0100_0000_0000_0000이 맞다.
<br> 이를 (마)에 반영하면 1 1000_0110 111_1101_0100_0000_0000_0000이 정답이다.

#### [문제3]<br>
부동소수점 표현으로는 ’0’을 나타낼 수 없는 이유를 설명하고, IEEE 754 표준 32-비트 부동소수점 형식에서의 ‘0’에 대한 비트 패턴을 표시하세요. <br>

부동소수점 표현식을 살펴보면 (-1)<sup>S</sup>2<sup>E-127</sup>(1.M) 이므로, 표현할 수 있는 가장 작은 절대값은 2<sup>-127</sup>(1.0)이다.
즉, 표현할 수 있는 가장 작은 수인 지수와 가수가 모두 0인 경우를 0으로 하며,<br>
0000_0000_0000_0000_0000_0000_0000_0000 혹은 1000_0000_0000_0000_0000_0000_0000_0000을 0이라고 할 수 있다.<br>
<br>

#### [문제4]<br>
10진수 '-1.625'를 IEEE 754 표준 32비트 부동소수점 형식으로 표현하세요.<br>

1.625는 2진수로 표현하면 1.101이다. <br>
부호 (S) 필드는 음수이므로 1 <br>
지수 (E) 필드는 0에서 127을 더한 0111_1111
가수 (E) 필드는 앞자리 1을 제외한 10100000...

그러므로 정답은 1_0111_1111_1010_0000_0000_0000_0000_000이다.


</details>
<br><br>

### 3.7 부동소수점 산술 연산　　	`gaekim`

```
[부동소수점 산술 연산 방법]

1. 덧셈 / 뺄셈

    1단계. 두 수의 지수가 같아지도록 만든다(소수점의 위치를 이동)

    2단계. 가수들끼리 덧셈 / 뺄셈한다

    3단계. 결과값을 정규화한다.(가수의 숫자가 소숫점 첫째자리에서 시작하도록)

          예시) 1.001001 x 2^5 → 0.1001001 x 2^6

2. 곱셈 / 나눗셈

    1단계. 가수끼리 곱한다

    2단계. 지수끼리 더하거나(곱셈) 뺀다(나눗셈)

    3단계. 정규화한다.
 ```   
    

- 다음 중 부동소수점 덧셈 과정에서 필요하지 않은 연산은 어느 것인가? [기본문제 3.15번]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 가. 지수 조정 &nbsp;&nbsp;&nbsp; 나. 정규화 &nbsp;&nbsp;&nbsp; 다. 지수 덧셈 &nbsp;&nbsp;&nbsp; 라. 가수 덧셈
- 다음 중 부동소수점 나눗셈 과정에서 필요하지 않은 연산은 어느 것인가? [기본문제 3.16번]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 가. 지수 조정 &nbsp;&nbsp;&nbsp; 나. 정규화 &nbsp;&nbsp;&nbsp; 다. 가수 나누기 &nbsp;&nbsp;&nbsp; 라. 지수 뺄셈
- 아래의 부동소수점 산술 연산들을 수행하고, 알맞은 답을 고르시오. [연습문제 3.24번 변형]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1번>  (0.111001 x 2<sup>-5</sup>) + (0.100111 x 2<sup>-3</sup>)
  
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (가) 0.11011101 x 2<sup>-3</sup> &nbsp;&nbsp;&nbsp; (나) 0.11010101 x 2<sup>-3</sup> &nbsp;&nbsp;&nbsp; (다) 0.11011111 x 2<sup>-3</sup> &nbsp;&nbsp;&nbsp; (라) 0.11010101 x 2<sup>-4</sup> <br/>

  
2번>  (0.100011 x 2<sup>6</sup>) - (0.111001 x 2<sup>3</sup>)<br/>
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (가) 1.1011111 x 2<sup>5</sup> &nbsp;&nbsp;&nbsp; (나) 0.11111111 x 2<sup>5</sup>&nbsp;&nbsp;&nbsp;  (다) 0.11011111 x 2<sup>5</sup> &nbsp;&nbsp;&nbsp; (라) 0.11011111 x 2<sup>9</sup> <br/>
  

3번>  (0.1001 x 2<sup>8</sup>) x (0.1011 x 2<sup>12</sup>)<br/>
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (가) 0.1100001 x 2<sup>19</sup> &nbsp;&nbsp;&nbsp; (나) 0.1010011 x 2<sup>19</sup>&nbsp;&nbsp;&nbsp;  (다) 0.1100011 x 2<sup>20</sup> &nbsp;&nbsp;&nbsp; (라) 0.1100011 x 2<sup>19</sup>  <br/>
  
- 부동소수점 산술연산 과정에서는 `__` 오버플로우, `__` 언더플로우, `__` 언더플로우, `__` 오버플로우 등의 문제가 발생할 가능성이 있다.


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
  

- 다음 중 부동소수점 덧셈 과정에서 필요하지 않은 연산은 어느 것인가? [기본문제 3.15번]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 가. 지수 조정 &nbsp;&nbsp;&nbsp; 나. 정규화 &nbsp;&nbsp;&nbsp; **다. 지수 덧셈** &nbsp;&nbsp;&nbsp; 라. 가수 덧셈
- 다음 중 부동소수점 나눗셈 과정에서 필요하지 않은 연산은 어느 것인가? [기본문제 3.16번]


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **가. 지수 조정** &nbsp;&nbsp;&nbsp; 나. 정규화 &nbsp;&nbsp;&nbsp; 다. 가수 나누기 &nbsp;&nbsp;&nbsp; 라. 지수 뺄셈
- 아래의 부동소수점 산술 연산들을 수행하고, 알맞은 답을 고르시오. [연습문제 3.24번 변형]


  1번>  (0.111001 x 2<sup>-5</sup>) + (0.100111 x 2<sup>-3</sup>)<br/>

  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (가) 0.11011101 x 2<sup>-3</sup> &nbsp;&nbsp;&nbsp; **(나) 0.11010101 x 2<sup>-3</sup>** &nbsp;&nbsp;&nbsp; (다) 0.11011111 x 2<sup>-3</sup> &nbsp;&nbsp;&nbsp; (라) 0.11010101 x 2<sup>-4</sup> <br/>
  
  
  
  
  
&nbsp; &nbsp; &nbsp; &nbsp;  2번>  (0.100011 x 2<sup>6</sup>) - (0.111001 x 2<sup>3</sup>)<br/>
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (가) 1.1011111 x 2<sup>5</sup> &nbsp;&nbsp;&nbsp; (나) 0.11111111 x 2<sup>5</sup>&nbsp;&nbsp;&nbsp;  **(다) 0.11011111 x 2<sup>5</sup> &nbsp;&nbsp;&nbsp;** (라) 0.11011111 x 2<sup>9</sup> <br/>
  

&nbsp; &nbsp; &nbsp; &nbsp;  3번>  (0.1001 x 2<sup>8</sup>) x (0.1011 x 2<sup>12</sup>)<br/>
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (가) 0.1100001 x 2<sup>19</sup> &nbsp;&nbsp;&nbsp; (나) 0.1010011 x 2<sup>19</sup>&nbsp;&nbsp;&nbsp;  (다) 0.1100011 x 2<sup>20</sup> &nbsp;&nbsp;&nbsp; **(라) 0.1100011 x 2<sup>19</sup>  <br/>**
  
  
  <img src = "https://user-images.githubusercontent.com/59970070/100898551-388f7880-3504-11eb-9ef7-d292843994be.jpg" width="70%" height="70%">

- 부동소수점 산술연산 과정에서는 `지수` 오버플로우, `지수` 언더플로우, `가수` 언더플로우, `가수` 오버플로우 등의 문제가 발생할 가능성이 있다.
   > 표현할 수 있는 범위를 넘어설 경우, 위와 같은 문제들이 발생할 수 있다.
</details>
<br><br>
